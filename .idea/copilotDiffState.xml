<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_db.py" />
              <option name="originalContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/create_db.py" />
              <option name="originalContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/chat_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/chat_service.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
              <option name="updatedContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>