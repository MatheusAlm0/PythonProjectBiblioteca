<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_db.py" />
              <option name="originalContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/create_db.py" />
              <option name="originalContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine, Column, String, TIMESTAMP, text, Text,Integer, UniqueConstraint, CheckConstraint,ForeignKey&#10;from sqlalchemy.dialects.postgresql import UUID, JSON&#10;from sqlalchemy.orm import declarative_base, sessionmaker,relationship&#10;import uuid&#10;&#10;DATABASE_URL = &quot;postgresql://postgres:postgres@localhost:5432/biblioteca&quot;&#10;#DATABASE_URL =  &quot;sqlite:///./biblioteca.db&quot;&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(bind=engine)&#10;Base = declarative_base()&#10;&#10;&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    email = Column(String(255), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    favorite_books = Column(JSON, default=list)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;    &#10;    avaliacoes = relationship('Avaliacao', back_populates='usuario', cascade='all, delete-orphan')&#10;&#10;class Livro(Base):&#10;    __tablename__ = 'livros'&#10;    &#10;    id = Column(Integer, primary_key=True)&#10;    google_books_id = Column(String(50), unique=True, nullable=False, index=True)&#10;    rate = Column(Integer,nullable=False,index=True)&#10;    usuario_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False)&#10;    # Relacionamento com avaliações&#10;    &#10;    &#10;    avaliacoes = relationship('Avaliacao', back_populates='livro', cascade='all, delete-orphan')&#10;&#10;&#10;class Avaliacao(Base):&#10;    __tablename__ = 'avaliacoes'&#10;    __table_args__ = (&#10;        UniqueConstraint('livro_id', 'usuario_id', name='uq_livro_usuario'),&#10;        CheckConstraint('estrelas &gt;= 1 AND estrelas &lt;= 5', name='ck_estrelas_range')&#10;    )&#10;    &#10;    id = Column(Integer, primary_key=True)&#10;    livro_id = Column(Integer, ForeignKey('livros.id'), nullable=False, index=True)&#10;    usuario_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False, index=True)&#10;    estrelas = Column(Integer, nullable=False)&#10;    comentario = Column(Text)&#10;    data_avaliacao = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;    &#10;    # Relacionamentos&#10;    livro = relationship('Livro', back_populates='avaliacoes')&#10;    usuario = relationship('User', back_populates='avaliacoes')&#10;&#10;&#10;&#10;&#10;#def get_db_session():&#10;    #return SessionLocal()&#10;&#10;&#10;&#10;&#10;&#10;&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;    session = SessionLocal()&#10;    try:&#10;        usuarios_padrao = [&#10;            {&#10;                'username': 'Teste',&#10;                'email': 'teste@local.com',&#10;                'password': 'senha123',&#10;                'favorite_books': [&#10;                    'zyTCAlFPjgYC',&#10;                    'wrOQLV6xB-wC',&#10;                    'nggnmAEACAAJ'&#10;                ]&#10;            },&#10;            {&#10;                'username': 'Matheus',&#10;                'email': 'matheus@gmail.com',&#10;                'password': 'senha123',&#10;                'favorite_books': [&#10;                    'PXa2bby0oQ0C',&#10;                    'IwywDwAAQBAJ',&#10;                    '1wy49d1FmLcC'&#10;                ]&#10;            }&#10;        ]&#10;&#10;        for user_data in usuarios_padrao:&#10;            if not session.query(User).filter_by(username=user_data['username']).first():&#10;                session.add(User(**user_data))&#10;&#10;        session.commit()&#10;    except Exception as e:&#10;        session.rollback()&#10;        print(f&quot;Erro ao inicializar usuários: {e}&quot;)&#10;    finally:&#10;        session.close()" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, String, TIMESTAMP, text, Text,Integer, UniqueConstraint, CheckConstraint,ForeignKey&#10;from sqlalchemy.dialects.postgresql import UUID, JSON&#10;from sqlalchemy.orm import declarative_base, sessionmaker,relationship&#10;import uuid&#10;&#10;DATABASE_URL = &quot;postgresql://postgres:postgres@localhost:5432/biblioteca&quot;&#10;#DATABASE_URL =  &quot;sqlite:///./biblioteca.db&quot;&#10;&#10;engine = create_engine(DATABASE_URL)&#10;SessionLocal = sessionmaker(bind=engine)&#10;Base = declarative_base()&#10;&#10;&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    email = Column(String(255), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    favorite_books = Column(JSON, default=list)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;    &#10;    avaliacoes = relationship('Avaliacao', back_populates='usuario', cascade='all, delete-orphan')&#10;&#10;class Livro(Base):&#10;    __tablename__ = 'livros'&#10;    &#10;    id = Column(Integer, primary_key=True)&#10;    google_books_id = Column(String(50), unique=True, nullable=False, index=True)&#10;    rate = Column(Integer,nullable=False,index=True)&#10;    usuario_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False)&#10;    # Relacionamento com avaliações&#10;    &#10;    &#10;    avaliacoes = relationship('Avaliacao', back_populates='livro', cascade='all, delete-orphan')&#10;&#10;&#10;class Avaliacao(Base):&#10;    __tablename__ = 'avaliacoes'&#10;    __table_args__ = (&#10;        UniqueConstraint('livro_id', 'usuario_id', name='uq_livro_usuario'),&#10;        CheckConstraint('estrelas &gt;= 1 AND estrelas &lt;= 5', name='ck_estrelas_range')&#10;    )&#10;    &#10;    id = Column(Integer, primary_key=True)&#10;    livro_id = Column(Integer, ForeignKey('livros.id'), nullable=False, index=True)&#10;    usuario_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False, index=True)&#10;    estrelas = Column(Integer, nullable=False)&#10;    comentario = Column(Text)&#10;    data_avaliacao = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;    &#10;    # Relacionamentos&#10;    livro = relationship('Livro', back_populates='avaliacoes')&#10;    usuario = relationship('User', back_populates='avaliacoes')&#10;&#10;&#10;&#10;&#10;#def get_db_session():&#10;    #return SessionLocal()&#10;&#10;&#10;&#10;&#10;&#10;&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;    session = SessionLocal()&#10;    try:&#10;        usuarios_padrao = [&#10;            {&#10;                'username': 'Teste',&#10;                'email': 'teste@local.com',&#10;                'password': 'senha123',&#10;                'favorite_books': [&#10;                    'zyTCAlFPjgYC',&#10;                    'wrOQLV6xB-wC',&#10;                    'nggnmAEACAAJ'&#10;                ]&#10;            },&#10;            {&#10;                'username': 'Matheus',&#10;                'email': 'matheus@gmail.com',&#10;                'password': 'senha123',&#10;                'favorite_books': [&#10;                    'PXa2bby0oQ0C',&#10;                    'IwywDwAAQBAJ',&#10;                    '1wy49d1FmLcC'&#10;                ]&#10;            }&#10;        ]&#10;&#10;        for user_data in usuarios_padrao:&#10;            if not session.query(User).filter_by(username=user_data['username']).first():&#10;                session.add(User(**user_data))&#10;&#10;        session.commit()&#10;    except Exception as e:&#10;        session.rollback()&#10;        print(f&quot;Erro ao inicializar usuários: {e}&quot;)&#10;    finally:&#10;        session.close()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>