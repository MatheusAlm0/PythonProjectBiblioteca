<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_db.py" />
              <option name="originalContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/create_db.py" />
              <option name="originalContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/chat_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/chat_service.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
              <option name="updatedContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/static/js/dashboard.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/static/js/dashboard.js" />
              <option name="originalContent" value="// Sistema de Notificações Toast&#10;function showToast(message, type = 'info', title = '') {&#10;  console.log('showToast called:', { message, type, title });&#10;&#10;  // Garantir que as animações estejam disponíveis&#10;  if (!document.getElementById('toast-animations')) {&#10;    const style = document.createElement('style');&#10;    style.id = 'toast-animations';&#10;    style.textContent = `&#10;      @keyframes slideIn {&#10;        from {&#10;          transform: translateX(400px);&#10;          opacity: 0;&#10;        }&#10;        to {&#10;          transform: translateX(0);&#10;          opacity: 1;&#10;        }&#10;      }&#10;      @keyframes slideOut {&#10;        from {&#10;          transform: translateX(0);&#10;          opacity: 1;&#10;        }&#10;        to {&#10;          transform: translateX(400px);&#10;          opacity: 0;&#10;        }&#10;      }&#10;      @keyframes pulseScale {&#10;        0%, 100% {&#10;          transform: scale(1);&#10;        }&#10;        50% {&#10;          transform: scale(1.15);&#10;        }&#10;      }&#10;    `;&#10;    document.head.appendChild(style);&#10;  }&#10;&#10;  const container = document.getElementById('toast-container');&#10;  console.log('Toast container found:', container);&#10;&#10;  if (!container) {&#10;    console.error('Toast container not found!');&#10;    return;&#10;  }&#10;&#10;  const toast = document.createElement('div');&#10;  toast.className = `toast toast-${type}`;&#10;&#10;  // Adicionar estilos inline críticos para garantir formatação&#10;  toast.style.cssText = `&#10;    background: white;&#10;    border-radius: 12px;&#10;    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);&#10;    padding: 16px 20px;&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 12px;&#10;    min-width: 300px;&#10;    max-width: 400px;&#10;    position: relative;&#10;    overflow: hidden;&#10;    margin-bottom: 12px;&#10;    animation: slideIn 0.3s ease-out;&#10;  `;&#10;&#10;  const icons = {&#10;    success: '✅',&#10;    error: '❌',&#10;    warning: '⚠️',&#10;    info: 'ℹ️'&#10;  };&#10;&#10;  const titles = {&#10;    success: title || 'Sucesso!',&#10;    error: title || 'Erro!',&#10;    warning: title || 'Atenção!',&#10;    info: title || 'Informação'&#10;  };&#10;&#10;  const borderColors = {&#10;    success: '#10b981',&#10;    error: '#ef4444',&#10;    warning: '#f59e0b',&#10;    info: '#3b82f6'&#10;  };&#10;&#10;  toast.style.borderLeft = `4px solid ${borderColors[type]}`;&#10;&#10;  toast.innerHTML = `&#10;    &lt;div class=&quot;toast-icon&quot; style=&quot;font-size: 24px; flex-shrink: 0;&quot;&gt;${icons[type]}&lt;/div&gt;&#10;    &lt;div class=&quot;toast-content&quot; style=&quot;flex: 1;&quot;&gt;&#10;      &lt;div class=&quot;toast-title&quot; style=&quot;font-weight: 600; color: #1e293b; margin-bottom: 4px; font-size: 14px;&quot;&gt;${titles[type]}&lt;/div&gt;&#10;      &lt;div class=&quot;toast-message&quot; style=&quot;color: #64748b; font-size: 13px; line-height: 1.4;&quot;&gt;${message}&lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;button class=&quot;toast-close&quot; onclick=&quot;this.parentElement.remove()&quot; style=&quot;background: none; border: none; color: #94a3b8; cursor: pointer; padding: 4px; font-size: 20px; line-height: 1;&quot;&gt;×&lt;/button&gt;&#10;  `;&#10;&#10;  container.appendChild(toast);&#10;  console.log('Toast added to container:', toast);&#10;&#10;  // Auto remover após 3 segundos&#10;  setTimeout(() =&gt; {&#10;    toast.classList.add('toast-exit');&#10;    setTimeout(() =&gt; toast.remove(), 300);&#10;  }, 3000);&#10;}&#10;&#10;// Sistema de Modal de Confirmação Personalizado&#10;function showConfirm(title, message, onConfirm, onCancel = null) {&#10;  const modal = document.getElementById('confirm-modal');&#10;  const titleEl = document.getElementById('confirm-title');&#10;  const messageEl = document.getElementById('confirm-message');&#10;  const confirmBtn = document.getElementById('confirm-ok');&#10;  const cancelBtn = document.getElementById('confirm-cancel');&#10;  const iconEl = document.querySelector('.confirm-icon');&#10;&#10;  if (!modal || !titleEl || !messageEl || !confirmBtn || !cancelBtn) return;&#10;&#10;  titleEl.textContent = title;&#10;  messageEl.textContent = message;&#10;&#10;  // Adicionar animação no ícone&#10;  if (iconEl) {&#10;    iconEl.style.animation = 'pulseScale 2s ease-in-out infinite';&#10;  }&#10;&#10;  // Limpar listeners antigos&#10;  const newConfirmBtn = confirmBtn.cloneNode(true);&#10;  const newCancelBtn = cancelBtn.cloneNode(true);&#10;  confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);&#10;  cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);&#10;&#10;  // Adicionar efeitos de hover ao botão cancelar&#10;  newCancelBtn.addEventListener('mouseenter', () =&gt; {&#10;    newCancelBtn.style.background = '#f1f5f9';&#10;    newCancelBtn.style.color = '#475569';&#10;    newCancelBtn.style.transform = 'scale(1.02)';&#10;  });&#10;  newCancelBtn.addEventListener('mouseleave', () =&gt; {&#10;    newCancelBtn.style.background = '#ffffff';&#10;    newCancelBtn.style.color = '#64748b';&#10;    newCancelBtn.style.transform = 'scale(1)';&#10;  });&#10;&#10;  // Adicionar efeitos de hover ao botão confirmar&#10;  newConfirmBtn.addEventListener('mouseenter', () =&gt; {&#10;    newConfirmBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';&#10;    newConfirmBtn.style.transform = 'scale(1.02)';&#10;    newConfirmBtn.style.boxShadow = 'inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 8px 24px rgba(239, 68, 68, 0.4)';&#10;  });&#10;  newConfirmBtn.addEventListener('mouseleave', () =&gt; {&#10;    newConfirmBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';&#10;    newConfirmBtn.style.transform = 'scale(1)';&#10;    newConfirmBtn.style.boxShadow = 'inset 0 1px 0 rgba(255, 255, 255, 0.2)';&#10;  });&#10;&#10;  // Adicionar novos listeners de click&#10;  newConfirmBtn.addEventListener('click', () =&gt; {&#10;    modal.style.display = 'none';&#10;    if (onConfirm) onConfirm();&#10;  });&#10;&#10;  newCancelBtn.addEventListener('click', () =&gt; {&#10;    modal.style.display = 'none';&#10;    if (onCancel) onCancel();&#10;  });&#10;&#10;  // Fechar ao clicar fora&#10;  modal.addEventListener('click', (e) =&gt; {&#10;    if (e.target === modal) {&#10;      modal.style.display = 'none';&#10;      if (onCancel) onCancel();&#10;    }&#10;  });&#10;&#10;  modal.style.display = 'flex';&#10;}&#10;&#10;// Função global para abrir modal de avaliação&#10;window.openRatingModal = function(bookId, currentStars = 0, currentComment = '', isEditing = false) {&#10;  const userId = localStorage.getItem('user_id');&#10;  const modal = document.getElementById('rating-modal');&#10;  const submitBtn = document.getElementById('submit-rating');&#10;  const cancelBtn = document.getElementById('cancel-rating');&#10;  const commentInput = document.getElementById('rating-comment');&#10;  const ratingText = document.getElementById('rating-text');&#10;  const charCount = document.getElementById('char-count');&#10;  let selectedRating = 0;&#10;&#10;  // Textos descritivos para cada nota&#10;  const ratingDescriptions = {&#10;    1: '⭐ Muito Ruim',&#10;    2: '⭐⭐ Ruim',&#10;    3: '⭐⭐⭐ Regular',&#10;    4: '⭐⭐⭐⭐ Bom',&#10;    5: '⭐⭐⭐⭐⭐ Excelente!'&#10;  };&#10;&#10;  // Reset e preparar modal&#10;  const starContainer = document.querySelector('.star-rating');&#10;  starContainer.innerHTML = `&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;1&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;2&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;3&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;4&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;5&quot;&gt;⭐&lt;/span&gt;&#10;  `;&#10;&#10;  commentInput.value = '';&#10;  ratingText.textContent = 'Selecione uma nota';&#10;  ratingText.classList.remove('has-rating');&#10;  charCount.textContent = '0';&#10;&#10;  // Preencher dados atuais (modo edição)&#10;  if(currentStars &gt; 0){&#10;    selectedRating = currentStars;&#10;    updateStarDisplay(selectedRating, true); // true = usar classe active (amarelo permanente)&#10;    ratingText.textContent = ratingDescriptions[selectedRating];&#10;    ratingText.classList.add('has-rating');&#10;  }&#10;  if(currentComment){&#10;    commentInput.value = currentComment;&#10;    charCount.textContent = currentComment.length;&#10;  }&#10;&#10;  // Função para atualizar display das estrelas&#10;  function updateStarDisplay(rating, useActive = false) {&#10;    const stars = document.querySelectorAll('.star-rating .star');&#10;    stars.forEach((star, i) =&gt; {&#10;      if(i &lt; rating){&#10;        // Estrelas selecionadas: amarelas&#10;        star.style.filter = 'grayscale(0%) brightness(1)';&#10;        star.style.opacity = '1';&#10;        star.style.transform = 'scale(1)';&#10;      } else {&#10;        // Estrelas não selecionadas: cinza&#10;        star.style.filter = 'grayscale(100%) brightness(1.1)';&#10;        star.style.opacity = '0.5';&#10;        star.style.transform = 'scale(1)';&#10;      }&#10;    });&#10;  }&#10;&#10;  // Event listeners para as estrelas&#10;  const stars = document.querySelectorAll('.star');&#10;  stars.forEach(star =&gt; {&#10;    // Hover&#10;    star.addEventListener('mouseenter', function(){&#10;      const rating = parseInt(this.dataset.rating);&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;      allStars.forEach((s, i) =&gt; {&#10;        if(i &lt; rating){&#10;          // Hover: mostrar preview amarelo&#10;          s.style.filter = 'grayscale(0%) brightness(1)';&#10;          s.style.opacity = '1';&#10;          s.style.transform = 'scale(1.15)';&#10;        } else {&#10;          // Manter cinza&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          s.style.transform = 'scale(1)';&#10;        }&#10;      });&#10;      ratingText.textContent = ratingDescriptions[rating];&#10;      ratingText.classList.add('has-rating');&#10;    });&#10;&#10;    // Mouse leave&#10;    star.addEventListener('mouseleave', function(){&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;      if(selectedRating &gt; 0) {&#10;        // Restaurar para o estado selecionado&#10;        allStars.forEach((s, i) =&gt; {&#10;          if(i &lt; selectedRating){&#10;            s.style.filter = 'grayscale(0%) brightness(1)';&#10;            s.style.opacity = '1';&#10;            s.style.transform = 'scale(1)';&#10;          } else {&#10;            s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;            s.style.opacity = '0.5';&#10;            s.style.transform = 'scale(1)';&#10;          }&#10;        });&#10;        ratingText.textContent = ratingDescriptions[selectedRating];&#10;        ratingText.classList.add('has-rating');&#10;      } else {&#10;        // Nenhuma selecionada: todas cinza&#10;        allStars.forEach(s =&gt; {&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          s.style.transform = 'scale(1)';&#10;        });&#10;        ratingText.textContent = 'Selecione uma nota';&#10;        ratingText.classList.remove('has-rating');&#10;      }&#10;    });&#10;&#10;    // Click&#10;    star.addEventListener('click', function(){&#10;      selectedRating = parseInt(this.dataset.rating);&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;&#10;      console.log('Clicked star with rating:', selectedRating);&#10;&#10;      allStars.forEach((s, i) =&gt; {&#10;        // Remover todas as classes e estilos primeiro&#10;        s.classList.remove('filled', 'active');&#10;&#10;        if(i &lt; selectedRating){&#10;          // Estrelas selecionadas: amarelas (sem grayscale)&#10;          s.classList.add('active');&#10;          s.style.filter = 'grayscale(0%) brightness(1)';&#10;          s.style.opacity = '1';&#10;          console.log('Star', i, 'set to ACTIVE (yellow)');&#10;        } else {&#10;          // Estrelas não selecionadas: cinza&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          console.log('Star', i, 'set to INACTIVE (gray)');&#10;        }&#10;      });&#10;&#10;      // Animar a estrela clicada&#10;      this.style.animation = 'starPop 0.3s ease-out';&#10;&#10;      ratingText.textContent = ratingDescriptions[selectedRating];&#10;      ratingText.classList.add('has-rating');&#10;&#10;      // Feedback tátil (se disponível)&#10;      if (navigator.vibrate) {&#10;        navigator.vibrate(10);&#10;      }&#10;    });&#10;  });&#10;&#10;  // Contador de caracteres&#10;  commentInput.addEventListener('input', function(){&#10;    charCount.textContent = this.value.length;&#10;  });&#10;&#10;  // Botão de cancelar&#10;  if(cancelBtn) {&#10;    cancelBtn.onclick = () =&gt; {&#10;      modal.style.display = 'none';&#10;      // Reabrir modal de avaliações se estava aberto&#10;      const ratingsModal = document.getElementById('ratings-modal');&#10;      if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;        ratingsModal.style.display = 'flex';&#10;        ratingsModal.dataset.wasOpen = 'false';&#10;      }&#10;    };&#10;  }&#10;&#10;  // Botão de submit&#10;  submitBtn.onclick = () =&gt; {&#10;    if(selectedRating === 0){&#10;      showToast('Por favor, selecione uma nota de 1 a 5 estrelas', 'warning', 'Avaliação incompleta');&#10;      // Animação de shake nas estrelas&#10;      const starRating = document.querySelector('.star-rating');&#10;      starRating.style.animation = 'none';&#10;      setTimeout(() =&gt; {&#10;        starRating.style.animation = 'shake 0.5s';&#10;      }, 10);&#10;      return;&#10;    }&#10;    const comment = commentInput.value.trim();&#10;    window.saveRating(bookId, selectedRating, comment, isEditing);&#10;    modal.style.display = 'none';&#10;  };&#10;&#10;  modal.style.display = 'flex';&#10;};&#10;&#10;// Função global para salvar avaliação&#10;window.saveRating = async function(bookId, stars, comment, reopenRatingsModal = false) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  try{&#10;    const payload = {&#10;      google_books_id: bookId,&#10;      estrelas: stars&#10;    };&#10;    if(comment) payload.comentario = comment;&#10;&#10;    const res = await fetch(`/api/users/${userId}/ratings`, {&#10;      method: 'POST',&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;        'Authorization': 'Bearer ' + userId&#10;      },&#10;      body: JSON.stringify(payload)&#10;    });&#10;    const data = await res.json();&#10;    if(res.ok) {&#10;      showToast(data.message || 'Avaliação salva com sucesso!', 'success');&#10;      // Só reabrir modal de avaliações se vier da edição&#10;      if(reopenRatingsModal) {&#10;        setTimeout(() =&gt; {&#10;          if(window.showRatings) window.showRatings();&#10;        }, 500);&#10;      }&#10;    } else {&#10;      showToast(data.error || 'Erro ao salvar avaliação', 'error');&#10;    }&#10;  }catch(e){&#10;    showToast('Erro: ' + e.message, 'error');&#10;  }&#10;};&#10;&#10;document.addEventListener('DOMContentLoaded', async ()=&gt;{&#10;  const userId = localStorage.getItem('user_id');&#10;  let isLoggedIn = false;&#10;  let username = '';&#10;&#10;  // Verificar se está logado (mas não redirecionar se não estiver)&#10;  if(userId){&#10;    try{&#10;      const res = await fetch('/auth/me', { headers: { 'Authorization': 'Bearer '+userId }});&#10;      const data = await res.json();&#10;      if(res.ok){&#10;        isLoggedIn = true;&#10;        username = data.username || 'Usuário';&#10;        document.getElementById('username').textContent = username;&#10;      }else{&#10;        localStorage.removeItem('user_id');&#10;        localStorage.removeItem('username');&#10;      }&#10;    }catch(e){&#10;      console.error('Erro ao validar sessão:', e);&#10;      localStorage.removeItem('user_id');&#10;      localStorage.removeItem('username');&#10;    }&#10;  }&#10;&#10;  // Atualizar botão de login/logout&#10;  const btnLogout = document.getElementById('btn-logout');&#10;  const btnLogin = document.getElementById('btn-login');&#10;  const btnFavoritesHeader = document.getElementById('btn-favorites');&#10;  const btnRatingsHeader = document.getElementById('btn-ratings');&#10;&#10;  if(isLoggedIn){&#10;    // Mostrar nome do usuário, botão de sair, favoritos e avaliações&#10;    document.getElementById('user-info').style.display = 'flex';&#10;    if(btnLogin) btnLogin.style.display = 'none';&#10;    if(btnFavoritesHeader) {&#10;      btnFavoritesHeader.style.display = 'block';&#10;      // Adicionar event listener para favoritos&#10;      btnFavoritesHeader.addEventListener('click', () =&gt; window.showFavorites());&#10;    }&#10;    if(btnRatingsHeader) {&#10;      btnRatingsHeader.style.display = 'block';&#10;      btnRatingsHeader.addEventListener('click', () =&gt; window.showRatings());&#10;    }&#10;&#10;    if(btnLogout){&#10;      btnLogout.addEventListener('click', async ()=&gt;{&#10;        try{&#10;          await fetch('/auth/logout', {&#10;            method: 'POST',&#10;            headers: {'Content-Type':'application/json'},&#10;            body: JSON.stringify({user_id: userId})&#10;          });&#10;        }catch(e){&#10;          console.error('Erro ao fazer logout:', e);&#10;        }&#10;        localStorage.removeItem('user_id');&#10;        localStorage.removeItem('username');&#10;        showToast('Você saiu com sucesso!', 'info', 'Até logo!');&#10;        setTimeout(() =&gt; location.reload(), 1000);&#10;      });&#10;    }&#10;  }else{&#10;    // Mostrar botão de login e ocultar favoritos e avaliações&#10;    document.getElementById('user-info').style.display = 'none';&#10;    if(btnFavoritesHeader) btnFavoritesHeader.style.display = 'none';&#10;    if(btnRatingsHeader) btnRatingsHeader.style.display = 'none';&#10;    if(btnLogin){&#10;      btnLogin.style.display = 'block';&#10;      btnLogin.addEventListener('click', ()=&gt; openAuthModal());&#10;    }&#10;  }&#10;&#10;  // Elementos do dashboard&#10;  const searchInput = document.getElementById('search-input');&#10;  const btnSearch = document.getElementById('btn-search');&#10;  const resultsContainer = document.getElementById('results-container');&#10;  const loading = document.getElementById('loading');&#10;  const bookModal = document.getElementById('book-modal');&#10;  const closeModal = document.querySelector('.close-modal');&#10;&#10;  // Variáveis para rastrear de onde o modal foi aberto&#10;  let openedFromFavorites = false;&#10;  let openedFromRatings = false;&#10;&#10;  // Buscar livros&#10;  if(btnSearch &amp;&amp; searchInput){&#10;    btnSearch.addEventListener('click', ()=&gt; searchBooks(searchInput.value.trim()));&#10;    searchInput.addEventListener('keypress', (e)=&gt; {&#10;      if(e.key === 'Enter') searchBooks(searchInput.value.trim());&#10;    });&#10;  }&#10;&#10;  // Fechar modal&#10;  if(closeModal){&#10;    closeModal.addEventListener('click', ()=&gt; {&#10;      bookModal.style.display = 'none';&#10;&#10;      // Se foi aberto dos favoritos, reabre o modal de favoritos&#10;      if (openedFromFavorites) {&#10;        openedFromFavorites = false;&#10;        document.getElementById('favorites-modal').style.display = 'flex';&#10;      }&#10;&#10;      // Se foi aberto das avaliações, reabre o modal de avaliações&#10;      if (openedFromRatings) {&#10;        openedFromRatings = false;&#10;        document.getElementById('ratings-modal').style.display = 'flex';&#10;      }&#10;    });&#10;  }&#10;  if(bookModal){&#10;    bookModal.addEventListener('click', (e)=&gt; {&#10;      if(e.target === bookModal) {&#10;        bookModal.style.display = 'none';&#10;&#10;        // Se foi aberto dos favoritos, reabre o modal de favoritos&#10;        if (openedFromFavorites) {&#10;          openedFromFavorites = false;&#10;          document.getElementById('favorites-modal').style.display = 'flex';&#10;        }&#10;&#10;        // Se foi aberto das avaliações, reabre o modal de avaliações&#10;        if (openedFromRatings) {&#10;          openedFromRatings = false;&#10;          document.getElementById('ratings-modal').style.display = 'flex';&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  // Função buscar livros&#10;  async function searchBooks(query){&#10;    console.log('searchBooks called with query:', query);&#10;&#10;    if(!query){&#10;      showToast('Digite o nome de um livro para buscar', 'warning');&#10;      return;&#10;    }&#10;&#10;    console.log('Mostrando loading...');&#10;    loading.style.display = 'block';&#10;    resultsContainer.innerHTML = '';&#10;&#10;    try{&#10;      console.log('Fazendo fetch para /api/books...');&#10;      const res = await fetch('/api/books', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': 'Bearer ' + userId&#10;        },&#10;        body: JSON.stringify({ findBook: query })&#10;      });&#10;&#10;      console.log('Response status:', res.status);&#10;      const data = await res.json();&#10;      console.log('Response data:', data);&#10;&#10;      if(!res.ok) throw new Error(data.error || 'Erro ao buscar livros');&#10;&#10;      displayBooks(data);&#10;    }catch(e){&#10;      console.error('Erro na busca:', e);&#10;      resultsContainer.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro na busca&lt;/h3&gt;&#10;          &lt;p&gt;${e.message}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }finally{&#10;      console.log('Escondendo loading...');&#10;      loading.style.display = 'none';&#10;    }&#10;  }&#10;&#10;  // Exibir livros&#10;  function displayBooks(books){&#10;    console.log('displayBooks called with:', books);&#10;&#10;    if(!books || books.length === 0){&#10;      resultsContainer.innerHTML = `&#10;        &lt;div class=&quot;no-results&quot;&gt;&#10;          &lt;div class=&quot;no-results-icon&quot;&gt;&lt;/div&gt;&#10;          &lt;h3&gt;Nenhum livro encontrado&lt;/h3&gt;&#10;          &lt;p&gt;Tente buscar com outros termos&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    console.log('Exibindo', books.length, 'livros');&#10;&#10;    // Criar grid de cards&#10;    const booksHTML = books.map(book =&gt; {&#10;      const thumbnail = book.imageLinks?.thumbnail || book.imageLinks?.smallThumbnail || '';&#10;      const authors = Array.isArray(book.authors) ? book.authors.join(', ') : (book.authors || 'Autor desconhecido');&#10;      const description = book.description || 'Sem descrição disponível';&#10;      const shortDescription = description.length &gt; 120 ? description.substring(0, 120) + '...' : description;&#10;&#10;      // Extrair ano de publicação se existir&#10;      const publishedYear = book.publishedDate ? book.publishedDate.split('-')[0] : '';&#10;&#10;      return `&#10;        &lt;div class=&quot;book-card&quot; onclick=&quot;loadBookDetails('${book.id}')&quot;&gt;&#10;          &lt;div class=&quot;book-thumbnail&quot;&gt;&#10;            ${thumbnail ?&#10;              `&lt;img src=&quot;${thumbnail}&quot; alt=&quot;${book.title}&quot; onerror=&quot;this.onerror=null; this.parentElement.innerHTML='&lt;div class=\\'book-no-cover\\'&gt;&lt;/div&gt;'&quot;&gt;` :&#10;              `&lt;div class=&quot;book-no-cover&quot;&gt;&lt;/div&gt;`&#10;            }&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;book-info&quot;&gt;&#10;            &lt;h3 class=&quot;book-title&quot;&gt;${book.title}&lt;/h3&gt;&#10;            &lt;p class=&quot;book-author&quot;&gt;${authors}&lt;/p&gt;&#10;            ${publishedYear ? `&lt;p class=&quot;book-year&quot;&gt;${publishedYear}&lt;/p&gt;` : ''}&#10;            &lt;p class=&quot;book-description&quot;&gt;${shortDescription}&lt;/p&gt;&#10;            &lt;div class=&quot;book-card-footer&quot;&gt;&#10;              &lt;span class=&quot;book-card-cta&quot;&gt;Ver detalhes →&lt;/span&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;    resultsContainer.innerHTML = `&lt;div class=&quot;books-grid&quot;&gt;${booksHTML}&lt;/div&gt;`;&#10;    console.log('Livros exibidos com sucesso em grid');&#10;  }&#10;&#10;  // Carregar detalhes&#10;  window.loadBookDetails = async function(bookId, fromFavorites = false, fromRatings = false){&#10;    console.log('loadBookDetails called with bookId:', bookId, 'fromFavorites:', fromFavorites, 'fromRatings:', fromRatings);&#10;&#10;    // Definir flags se foi aberto dos favoritos ou avaliações&#10;    openedFromFavorites = fromFavorites;&#10;    openedFromRatings = fromRatings;&#10;&#10;    // Fechar modal de favoritos se estiver aberto&#10;    const favoritesModal = document.getElementById('favorites-modal');&#10;    if (favoritesModal &amp;&amp; favoritesModal.style.display === 'flex') {&#10;      favoritesModal.style.display = 'none';&#10;    }&#10;&#10;    // Fechar modal de avaliações se estiver aberto&#10;    const ratingsModal = document.getElementById('ratings-modal');&#10;    if (ratingsModal &amp;&amp; ratingsModal.style.display === 'flex') {&#10;      ratingsModal.style.display = 'none';&#10;    }&#10;&#10;    const bookDetails = document.getElementById('book-details');&#10;    bookDetails.innerHTML = '&lt;div class=&quot;loading&quot;&gt;&lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;&lt;p&gt;Carregando...&lt;/p&gt;&lt;/div&gt;';&#10;    bookModal.style.display = 'flex';&#10;&#10;    try{&#10;      console.log('Fetching book details from:', `/api/books/${bookId}`);&#10;      const res = await fetch(`/api/books/${bookId}`, {&#10;        method: 'GET',&#10;        headers: { 'Authorization': 'Bearer ' + userId }&#10;      });&#10;&#10;      console.log('Book details response status:', res.status);&#10;      const data = await res.json();&#10;      console.log('Book details data:', data);&#10;&#10;      if(!res.ok) throw new Error(data.error || 'Erro ao carregar detalhes');&#10;&#10;      // Backend retorna {book: {...}, avaliacoes: [...]}&#10;      // Precisamos mesclar book com avaliacoes&#10;      const bookData = {&#10;        ...data.book,&#10;        avaliacoes: data.avaliacoes || []&#10;      };&#10;&#10;      console.log('Merged book data:', bookData);&#10;      displayBookDetails(bookData);&#10;    }catch(e){&#10;      console.error('Erro ao carregar detalhes:', e);&#10;      bookDetails.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro&lt;/h3&gt;&#10;          &lt;p&gt;${e.message}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }&#10;  };&#10;&#10;  // Exibir detalhes&#10;  function displayBookDetails(book){&#10;    console.log('displayBookDetails called with:', book);&#10;    console.log('book.title:', book.title);&#10;    console.log('book.authors:', book.authors);&#10;    console.log('book.imageLinks:', book.imageLinks);&#10;&#10;    if(!book || !book.title){&#10;      const bookDetails = document.getElementById('book-details');&#10;      bookDetails.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro&lt;/h3&gt;&#10;          &lt;p&gt;Dados do livro inválidos ou incompletos&lt;/p&gt;&#10;          &lt;pre&gt;${JSON.stringify(book, null, 2)}&lt;/pre&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    const bookDetails = document.getElementById('book-details');&#10;    const thumbnail = book.imageLinks?.thumbnail || '';&#10;    const authors = Array.isArray(book.authors) &amp;&amp; book.authors.length &gt; 0&#10;      ? book.authors.join(', ')&#10;      : 'Autor desconhecido';&#10;    const publisher = book.publisher || '';&#10;    const publishedDate = book.publishedDate || '';&#10;    const publisherInfo = [publisher, publishedDate].filter(x =&gt; x).join(' - ');&#10;    const title = book.title || 'Título não disponível';&#10;    const description = book.description || 'Sem descrição disponível.';&#10;&#10;    bookDetails.innerHTML = `&#10;      &lt;div class=&quot;book-detail-header&quot;&gt;&#10;        ${thumbnail ?&#10;          `&lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.style.display='none'&quot;&gt;` :&#10;          `&lt;div class=&quot;book-no-image&quot;&gt;&lt;/div&gt;`&#10;        }&#10;        &lt;div&gt;&#10;          &lt;h2&gt;${title}&lt;/h2&gt;&#10;          &lt;p class=&quot;author&quot;&gt;${authors}&lt;/p&gt;&#10;          ${publisherInfo ? `&lt;p class=&quot;publisher&quot;&gt;${publisherInfo}&lt;/p&gt;` : ''}&#10;          ${book.pageCount ? `&lt;p class=&quot;pages&quot;&gt; ${book.pageCount} páginas&lt;/p&gt;` : ''}&#10;          ${book.language ? `&lt;p class=&quot;language&quot;&gt; Idioma: ${book.language.toUpperCase()}&lt;/p&gt;` : ''}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;book-detail-body&quot;&gt;&#10;        &lt;h3&gt; Descrição&lt;/h3&gt;&#10;        &lt;p&gt;${description}&lt;/p&gt;&#10;&#10;        ${book.categories &amp;&amp; book.categories.length &gt; 0 ? `&#10;          &lt;h3&gt;️ Categorias&lt;/h3&gt;&#10;          &lt;p&gt;${book.categories.join(', ')}&lt;/p&gt;&#10;        ` : ''}&#10;&#10;        ${book.avaliacoes &amp;&amp; book.avaliacoes.length &gt; 0 ? `&#10;          &lt;h3&gt;⭐ Avaliações&lt;/h3&gt;&#10;          &lt;div class=&quot;avaliacoes&quot;&gt;&#10;            ${book.avaliacoes.map(av =&gt; `&#10;              &lt;div class=&quot;avaliacao&quot;&gt;&#10;                &lt;strong&gt;${av.usuario_nome}&lt;/strong&gt; - ${'⭐'.repeat(av.estrelas)}&#10;                ${av.comentario ? `&lt;p&gt;${av.comentario}&lt;/p&gt;` : ''}&#10;                &lt;small&gt;${new Date(av.data_avaliacao).toLocaleDateString('pt-BR')}&lt;/small&gt;&#10;              &lt;/div&gt;&#10;            `).join('')}&#10;          &lt;/div&gt;&#10;        ` : ''}&#10;&#10;        &lt;div class=&quot;book-actions&quot;&gt;&#10;          &lt;button class=&quot;btn-primary&quot; onclick=&quot;addToFavorites('${book.id}')&quot;&gt;❤️ Favoritar&lt;/button&gt;&#10;          &lt;button class=&quot;btn-secondary&quot; onclick=&quot;rateBook('${book.id}')&quot;&gt;⭐ Avaliar&lt;/button&gt;&#10;          ${book.previewLink ? `&lt;a href=&quot;${book.previewLink}&quot; target=&quot;_blank&quot; class=&quot;btn-link&quot;&gt;️ Prévia&lt;/a&gt;` : ''}&#10;          ${book.infoLink ? `&lt;a href=&quot;${book.infoLink}&quot; target=&quot;_blank&quot; class=&quot;btn-link&quot;&gt;ℹ️ Mais informações&lt;/a&gt;` : ''}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;    console.log('Book details displayed successfully');&#10;  }&#10;&#10;  // Adicionar aos favoritos&#10;  window.addToFavorites = async function(bookId){&#10;    if(!isLoggedIn){&#10;      showToast('Faça login para adicionar livros aos favoritos', 'warning', 'Login necessário');&#10;      setTimeout(() =&gt; openAuthModal('login'), 500);&#10;      return;&#10;    }&#10;    try{&#10;      const res = await fetch(`/api/users/${userId}/favorites`, {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': 'Bearer ' + userId&#10;        },&#10;        body: JSON.stringify({ book_id: bookId })&#10;      });&#10;      const data = await res.json();&#10;      if(res.ok) showToast('Livro adicionado aos favoritos!', 'success');&#10;      else showToast(data.error || 'Erro ao adicionar favorito', 'error');&#10;    }catch(e){&#10;      showToast('Erro: ' + e.message, 'error');&#10;    }&#10;  };&#10;&#10;  // Avaliar livro&#10;  window.rateBook = async function(bookId){&#10;    if(!isLoggedIn){&#10;      showToast('Faça login para avaliar livros', 'warning', 'Login necessário');&#10;      setTimeout(() =&gt; openAuthModal('login'), 500);&#10;      return;&#10;    }&#10;&#10;    // Verificar se o usuário já avaliou este livro&#10;    try {&#10;      const res = await fetch(`/api/ratings/${bookId}/check?user_id=${userId}`);&#10;      const data = await res.json();&#10;&#10;      if(res.ok &amp;&amp; data.ja_avaliou) {&#10;        showToast('Livro já avaliado! Acesse &quot;Minhas Avaliações&quot; para editar sua avaliação.', 'info', 'Já avaliado');&#10;        return;&#10;      }&#10;    } catch(e) {&#10;      console.error('Erro ao verificar avaliação:', e);&#10;      // Se der erro na verificação, continua e deixa abrir o modal&#10;    }&#10;&#10;    window.openRatingModal(bookId);&#10;  };&#10;&#10;  // Gerenciar fechamento do modal de rating&#10;  const ratingModal = document.getElementById('rating-modal');&#10;  const closeRatingModal = document.getElementById('close-rating-modal');&#10;&#10;  if(closeRatingModal){&#10;    closeRatingModal.addEventListener('click', ()=&gt; {&#10;      ratingModal.style.display = 'none';&#10;      // Reabrir modal de avaliações se estava aberto&#10;      const ratingsModal = document.getElementById('ratings-modal');&#10;      if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;        ratingsModal.style.display = 'flex';&#10;        ratingsModal.dataset.wasOpen = 'false';&#10;      }&#10;    });&#10;  }&#10;&#10;  // Fechar ao clicar fora do modal&#10;  if(ratingModal){&#10;    ratingModal.addEventListener('click', (e)=&gt; {&#10;      if(e.target === ratingModal) {&#10;        ratingModal.style.display = 'none';&#10;        // Reabrir modal de avaliações se estava aberto&#10;        const ratingsModal = document.getElementById('ratings-modal');&#10;        if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;          ratingsModal.style.display = 'flex';&#10;          ratingsModal.dataset.wasOpen = 'false';&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  // Modal de autenticação&#10;  const authModal = document.getElementById('auth-modal');&#10;  const authClose = document.querySelector('.auth-close');&#10;&#10;  if(authClose){&#10;    authClose.addEventListener('click', ()=&gt; authModal.style.display = 'none');&#10;  }&#10;&#10;  window.openAuthModal = function(mode = 'login'){&#10;    const loginForm = document.getElementById('login-form-container');&#10;    const registerForm = document.getElementById('register-form-container');&#10;&#10;    if(mode === 'login'){&#10;      loginForm.style.display = 'block';&#10;      registerForm.style.display = 'none';&#10;    }else{&#10;      loginForm.style.display = 'none';&#10;      registerForm.style.display = 'block';&#10;    }&#10;&#10;    authModal.style.display = 'flex';&#10;  };&#10;&#10;  window.switchToRegister = function(){&#10;    document.getElementById('login-form-container').style.display = 'none';&#10;    document.getElementById('register-form-container').style.display = 'block';&#10;  };&#10;&#10;  window.switchToLogin = function(){&#10;    document.getElementById('register-form-container').style.display = 'none';&#10;    document.getElementById('login-form-container').style.display = 'block';&#10;  };&#10;&#10;  // Login&#10;  const loginForm = document.getElementById('login-form');&#10;  if(loginForm){&#10;    loginForm.addEventListener('submit', async (e)=&gt;{&#10;      e.preventDefault();&#10;      const username = document.getElementById('login-username').value;&#10;      const password = document.getElementById('login-password').value;&#10;&#10;      try{&#10;        const res = await fetch('/auth/login', {&#10;          method: 'POST',&#10;          headers: {'Content-Type':'application/json'},&#10;          body: JSON.stringify({username, password})&#10;        });&#10;        const data = await res.json();&#10;&#10;        if(res.ok){&#10;          localStorage.setItem('user_id', data.user_id);&#10;          localStorage.setItem('username', data.username);&#10;          showToast(`Bem-vindo(a), ${data.username}!`, 'success', 'Login realizado!');&#10;          setTimeout(() =&gt; location.reload(), 1000);&#10;        }else{&#10;          showToast(data.error || 'Falha no login', 'error');&#10;        }&#10;      }catch(e){&#10;        showToast('Erro: ' + e.message, 'error');&#10;      }&#10;    });&#10;  }&#10;&#10;  // Registro&#10;  const registerForm = document.getElementById('register-form');&#10;  if(registerForm){&#10;    registerForm.addEventListener('submit', async (e)=&gt;{&#10;      e.preventDefault();&#10;      const username = document.getElementById('register-username').value;&#10;      const email = document.getElementById('register-email').value;&#10;      const password = document.getElementById('register-password').value;&#10;&#10;      try{&#10;        const res = await fetch('/auth/register', {&#10;          method: 'POST',&#10;          headers: {'Content-Type':'application/json'},&#10;          body: JSON.stringify({username, email, password})&#10;        });&#10;        const data = await res.json();&#10;&#10;        if(res.status === 201){&#10;          showToast('✅ Cadastro realizado com sucesso!', 'success');&#10;          &#10;          // Limpar campos&#10;          document.getElementById('register-username').value = '';&#10;          document.getElementById('register-email').value = '';&#10;          document.getElementById('register-password').value = '';&#10;          &#10;          // Mudar para formulário de login após 1.5s&#10;          setTimeout(() =&gt; {&#10;            window.switchToLogin();&#10;          }, 1500);&#10;        }else{&#10;          showToast(data.error || 'Falha no cadastro', 'error');&#10;        }&#10;      }catch(e){&#10;        showToast('Erro: ' + e.message, 'error');&#10;      }&#10;    });&#10;  }&#10;&#10;  // Fechar modal de favoritos&#10;  const favoritesClose = document.querySelector('.favorites-close');&#10;  if(favoritesClose){&#10;    favoritesClose.addEventListener('click', ()=&gt;{&#10;      document.getElementById('favorites-modal').style.display = 'none';&#10;    });&#10;  }&#10;&#10;  // Fechar modal de avaliações&#10;  const ratingsClose = document.querySelector('.ratings-close');&#10;  if(ratingsClose){&#10;    ratingsClose.addEventListener('click', ()=&gt;{&#10;      document.getElementById('ratings-modal').style.display = 'none';&#10;    });&#10;  }&#10;&#10;  // Os event listeners dos botões de favoritos e avaliações agora são&#10;  // adicionados dentro do bloco de login (linhas 72-83)&#10;&#10;  // Fechar modais ao clicar fora&#10;  window.addEventListener('click', (e) =&gt; {&#10;    const bookModal = document.getElementById('book-modal');&#10;    const authModal = document.getElementById('auth-modal');&#10;    const favoritesModal = document.getElementById('favorites-modal');&#10;    const ratingsModal = document.getElementById('ratings-modal');&#10;&#10;    if (e.target === bookModal) {&#10;      bookModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === authModal) {&#10;      authModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === favoritesModal) {&#10;      favoritesModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === ratingsModal) {&#10;      ratingsModal.style.display = 'none';&#10;    }&#10;  });&#10;});&#10;&#10;// Função para mostrar favoritos&#10;window.showFavorites = async function() {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    openAuthModal();&#10;    return;&#10;  }&#10;&#10;  const modal = document.getElementById('favorites-modal');&#10;  const content = document.getElementById('favorites-content');&#10;&#10;  content.innerHTML = '&lt;p style=&quot;text-align: center; padding: 40px;&quot;&gt;Carregando favoritos...&lt;/p&gt;';&#10;  modal.style.display = 'flex';&#10;&#10;  try {&#10;    const res = await fetch(`/api/users/${userId}/favorites`);&#10;    const data = await res.json();&#10;&#10;    if (!res.ok) {&#10;      throw new Error(data.error || 'Erro ao carregar favoritos');&#10;    }&#10;&#10;    if (!data.favorite_books || data.favorite_books.length === 0) {&#10;      content.innerHTML = `&#10;        &lt;div class=&quot;no-favorites&quot;&gt;&#10;          &lt;div class=&quot;no-favorites-icon&quot;&gt;&lt;/div&gt;&#10;          &lt;div class=&quot;no-favorites-text&quot;&gt;Nenhum livro favorito ainda&lt;/div&gt;&#10;          &lt;div class=&quot;no-favorites-subtext&quot;&gt;Explore livros e adicione aos seus favoritos!&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    // Buscar detalhes de cada livro favorito&#10;    const bookPromises = data.favorite_books.map(bookId =&gt;&#10;      fetch(`/api/books/${bookId}`).then(r =&gt; r.json())&#10;    );&#10;&#10;    const books = await Promise.all(bookPromises);&#10;&#10;    content.innerHTML = books.map(book =&gt; {&#10;      const bookData = book.book || book;&#10;      const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || '/static/img/book-placeholder.png';&#10;      const title = bookData.title || 'Título desconhecido';&#10;      const authors = bookData.authors ? bookData.authors.join(', ') : 'Autor desconhecido';&#10;&#10;      return `&#10;        &lt;div class=&quot;favorite-item&quot; onclick=&quot;loadBookDetails('${bookData.id}', true)&quot;&gt;&#10;          &lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.src='/static/img/book-placeholder.png'&quot;&gt;&#10;          &lt;div class=&quot;favorite-item-title&quot;&gt;${title}&lt;/div&gt;&#10;          &lt;div class=&quot;favorite-item-author&quot;&gt;${authors}&lt;/div&gt;&#10;          &lt;div class=&quot;favorite-item-actions&quot; onclick=&quot;event.stopPropagation()&quot;&gt;&#10;            &lt;button class=&quot;btn-remove-favorite&quot; onclick=&quot;removeFavorite('${bookData.id}')&quot;&gt;️ Remover&lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;  } catch (error) {&#10;    console.error('Erro ao carregar favoritos:', error);&#10;    content.innerHTML = `&#10;      &lt;div class=&quot;no-favorites&quot;&gt;&#10;        &lt;div class=&quot;no-favorites-icon&quot;&gt;⚠️&lt;/div&gt;&#10;        &lt;div class=&quot;no-favorites-text&quot;&gt;Erro ao carregar favoritos&lt;/div&gt;&#10;        &lt;div class=&quot;no-favorites-subtext&quot;&gt;${error.message}&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;  }&#10;}&#10;&#10;// Função para remover favorito&#10;async function removeFavorite(bookId) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  showConfirm(&#10;    'Remover dos Favoritos',&#10;    'Tem certeza que deseja remover este livro dos seus favoritos?',&#10;    async () =&gt; {&#10;      try {&#10;        const res = await fetch(`/api/users/${userId}/favorites/${bookId}`, {&#10;          method: 'DELETE'&#10;        });&#10;&#10;        const data = await res.json();&#10;&#10;        if (res.ok) {&#10;          showToast('Livro removido dos favoritos!', 'success', 'Removido!');&#10;          window.showFavorites(); // Recarregar lista&#10;        } else {&#10;          showToast(data.error || 'Erro ao remover favorito', 'error');&#10;        }&#10;      } catch (error) {&#10;        console.error('Erro ao remover favorito:', error);&#10;        showToast('Erro ao remover favorito: ' + error.message, 'error');&#10;      }&#10;    }&#10;  );&#10;}&#10;&#10;// Função para mostrar avaliações&#10;// Função para mostrar avaliações&#10;window.showRatings = async function() {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    openAuthModal();&#10;    return;&#10;  }&#10;&#10;  const ratingsModal = document.getElementById('ratings-modal');&#10;  const ratingsList = document.getElementById('ratings-list');&#10;&#10;  ratingsList.innerHTML = '&lt;p style=&quot;text-align: center; padding: 40px;&quot;&gt;Carregando avaliações...&lt;/p&gt;';&#10;&#10;  ratingsModal.style.display = 'flex';&#10;&#10;  try {&#10;    const res = await fetch(`/api/ratings/user/${userId}`);&#10;    const data = await res.json();&#10;&#10;    if (!res.ok) {&#10;      throw new Error(data.error || 'Erro ao carregar avaliações');&#10;    }&#10;&#10;    if (!data.ratings || data.ratings.length === 0) {&#10;      ratingsList.innerHTML = `&#10;        &lt;div class=&quot;no-ratings&quot;&gt;&#10;          &lt;div class=&quot;no-ratings-icon&quot;&gt;⭐&lt;/div&gt;&#10;          &lt;div class=&quot;no-ratings-text&quot;&gt;Nenhuma avaliação ainda&lt;/div&gt;&#10;          &lt;div class=&quot;no-ratings-subtext&quot;&gt;Avalie livros para aparecerem aqui!&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    // Buscar detalhes de cada livro avaliado&#10;    const bookPromises = data.ratings.map(rating =&gt;&#10;      fetch(`/api/books/${rating.google_books_id}`).then(r =&gt; r.json())&#10;    );&#10;&#10;    const books = await Promise.all(bookPromises);&#10;&#10;    ratingsList.innerHTML = data.ratings.map((rating, index) =&gt; {&#10;      const book = books[index];&#10;      const bookData = book.book || book;&#10;      const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || '/static/img/book-placeholder.png';&#10;      const title = bookData.title || 'Título desconhecido';&#10;      const authors = bookData.authors ? bookData.authors.join(', ') : 'Autor desconhecido';&#10;      const dataAvaliacao = new Date(rating.data_avaliacao).toLocaleDateString('pt-BR');&#10;&#10;      // Gerar estrelas preenchidas e vazias&#10;      let starsHtml = '';&#10;      for (let i = 1; i &lt;= 5; i++) {&#10;        if (i &lt;= rating.estrelas) {&#10;          starsHtml += '&lt;span class=&quot;star filled&quot;&gt;⭐&lt;/span&gt;';&#10;        } else {&#10;          starsHtml += '&lt;span class=&quot;star empty&quot;&gt;☆&lt;/span&gt;';&#10;        }&#10;      }&#10;&#10;      return `&#10;        &lt;div class=&quot;rating-item&quot; onclick=&quot;loadBookDetails('${bookData.id}', false, true)&quot;&gt;&#10;          &lt;div class=&quot;rating-item-image&quot;&gt;&#10;            &lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.src='/static/img/book-placeholder.png'&quot;&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;rating-item-info&quot;&gt;&#10;            &lt;h3 class=&quot;rating-item-title&quot;&gt;${title}&lt;/h3&gt;&#10;            &lt;div class=&quot;rating-item-author&quot;&gt;${authors}&lt;/div&gt;&#10;            &lt;div class=&quot;rating-stars&quot;&gt;&#10;              ${starsHtml}&#10;              &lt;span style=&quot;margin-left: 8px; color: #6b7280;&quot;&gt;(${rating.estrelas}/5)&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            ${rating.comentario ? `&lt;div class=&quot;rating-item-comment&quot;&gt;&quot;${rating.comentario}&quot;&lt;/div&gt;` : ''}&#10;            &lt;div class=&quot;rating-item-date&quot;&gt;Avaliado em: ${dataAvaliacao}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;rating-item-actions&quot; onclick=&quot;event.stopPropagation()&quot;&gt;&#10;            &lt;button class=&quot;btn-edit-rating&quot; onclick=&quot;editRating('${rating.google_books_id}', ${rating.estrelas}, '${rating.comentario ? rating.comentario.replace(/'/g, &quot;\\'&quot;) : ''}')&quot;&gt;✏️ Editar&lt;/button&gt;&#10;            &lt;button class=&quot;btn-delete-rating&quot; onclick=&quot;deleteRating('${rating.google_books_id}')&quot;&gt;️ Remover&lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;  } catch (error) {&#10;    console.error('Erro ao carregar avaliações:', error);&#10;    ratingsList.innerHTML = `&#10;      &lt;div class=&quot;no-ratings&quot;&gt;&#10;        &lt;div class=&quot;no-ratings-icon&quot;&gt;⚠️&lt;/div&gt;&#10;        &lt;div class=&quot;no-ratings-text&quot;&gt;Erro ao carregar avaliações&lt;/div&gt;&#10;        &lt;div class=&quot;no-ratings-subtext&quot;&gt;${error.message}&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;  }&#10;}&#10;&#10;// Função para editar avaliação&#10;window.editRating = async function(bookId, currentStars, currentComment) {&#10;  // Fechar modal de avaliações se estiver aberto&#10;  const ratingsModal = document.getElementById('ratings-modal');&#10;  if (ratingsModal &amp;&amp; ratingsModal.style.display === 'flex') {&#10;    ratingsModal.dataset.wasOpen = 'true';&#10;    ratingsModal.style.display = 'none';&#10;  }&#10;&#10;  // Passar true para isEditing para reabrir modal de avaliações após salvar&#10;  window.openRatingModal(bookId, currentStars, currentComment, true);&#10;};&#10;&#10;// Função para deletar avaliação&#10;window.deleteRating = async function(bookId) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    showToast('Você precisa estar logado para remover avaliações', 'error');&#10;    return;&#10;  }&#10;&#10;  showConfirm(&#10;    'Remover Avaliação',&#10;    'Tem certeza que deseja remover esta avaliação?',&#10;    async () =&gt; {&#10;      try {&#10;        const res = await fetch(`/api/ratings/${bookId}?user_id=${userId}`, {&#10;          method: 'DELETE'&#10;        });&#10;&#10;        const data = await res.json();&#10;&#10;        if (res.ok) {&#10;          showToast('Avaliação removida com sucesso!', 'success', 'Removido!');&#10;          window.showRatings(); // Recarregar lista&#10;        } else {&#10;          showToast(data.error || 'Erro ao remover avaliação', 'error');&#10;        }&#10;      } catch (error) {&#10;        console.error('Erro ao remover avaliação:', error);&#10;        showToast('Erro ao remover avaliação: ' + error.message, 'error');&#10;      }&#10;    }&#10;  );&#10;}&#10;&#10;" />
              <option name="updatedContent" value="// Sistema de Notificações Toast&#10;function showToast(message, type = 'info', title = '') {&#10;  console.log('showToast called:', { message, type, title });&#10;&#10;  // Garantir que as animações estejam disponíveis&#10;  if (!document.getElementById('toast-animations')) {&#10;    const style = document.createElement('style');&#10;    style.id = 'toast-animations';&#10;    style.textContent = `&#10;      @keyframes slideIn {&#10;        from {&#10;          transform: translateX(400px);&#10;          opacity: 0;&#10;        }&#10;        to {&#10;          transform: translateX(0);&#10;          opacity: 1;&#10;        }&#10;      }&#10;      @keyframes slideOut {&#10;        from {&#10;          transform: translateX(0);&#10;          opacity: 1;&#10;        }&#10;        to {&#10;          transform: translateX(400px);&#10;          opacity: 0;&#10;        }&#10;      }&#10;      @keyframes pulseScale {&#10;        0%, 100% {&#10;          transform: scale(1);&#10;        }&#10;        50% {&#10;          transform: scale(1.15);&#10;        }&#10;      }&#10;    `;&#10;    document.head.appendChild(style);&#10;  }&#10;&#10;  const container = document.getElementById('toast-container');&#10;  console.log('Toast container found:', container);&#10;&#10;  if (!container) {&#10;    console.error('Toast container not found!');&#10;    return;&#10;  }&#10;&#10;  const toast = document.createElement('div');&#10;  toast.className = `toast toast-${type}`;&#10;&#10;  // Adicionar estilos inline críticos para garantir formatação&#10;  toast.style.cssText = `&#10;    background: white;&#10;    border-radius: 12px;&#10;    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);&#10;    padding: 16px 20px;&#10;    display: flex;&#10;    align-items: center;&#10;    gap: 12px;&#10;    min-width: 300px;&#10;    max-width: 400px;&#10;    position: relative;&#10;    overflow: hidden;&#10;    margin-bottom: 12px;&#10;    animation: slideIn 0.3s ease-out;&#10;  `;&#10;&#10;  const icons = {&#10;    success: '✅',&#10;    error: '❌',&#10;    warning: '⚠️',&#10;    info: 'ℹ️'&#10;  };&#10;&#10;  const titles = {&#10;    success: title || 'Sucesso!',&#10;    error: title || 'Erro!',&#10;    warning: title || 'Atenção!',&#10;    info: title || 'Informação'&#10;  };&#10;&#10;  const borderColors = {&#10;    success: '#10b981',&#10;    error: '#ef4444',&#10;    warning: '#f59e0b',&#10;    info: '#3b82f6'&#10;  };&#10;&#10;  toast.style.borderLeft = `4px solid ${borderColors[type]}`;&#10;&#10;  toast.innerHTML = `&#10;    &lt;div class=&quot;toast-icon&quot; style=&quot;font-size: 24px; flex-shrink: 0;&quot;&gt;${icons[type]}&lt;/div&gt;&#10;    &lt;div class=&quot;toast-content&quot; style=&quot;flex: 1;&quot;&gt;&#10;      &lt;div class=&quot;toast-title&quot; style=&quot;font-weight: 600; color: #1e293b; margin-bottom: 4px; font-size: 14px;&quot;&gt;${titles[type]}&lt;/div&gt;&#10;      &lt;div class=&quot;toast-message&quot; style=&quot;color: #64748b; font-size: 13px; line-height: 1.4;&quot;&gt;${message}&lt;/div&gt;&#10;    &lt;/div&gt;&#10;    &lt;button class=&quot;toast-close&quot; onclick=&quot;this.parentElement.remove()&quot; style=&quot;background: none; border: none; color: #94a3b8; cursor: pointer; padding: 4px; font-size: 20px; line-height: 1;&quot;&gt;×&lt;/button&gt;&#10;  `;&#10;&#10;  container.appendChild(toast);&#10;  console.log('Toast added to container:', toast);&#10;&#10;  // Auto remover após 3 segundos&#10;  setTimeout(() =&gt; {&#10;    toast.classList.add('toast-exit');&#10;    setTimeout(() =&gt; toast.remove(), 300);&#10;  }, 3000);&#10;}&#10;&#10;// Sistema de Modal de Confirmação Personalizado&#10;function showConfirm(title, message, onConfirm, onCancel = null) {&#10;  const modal = document.getElementById('confirm-modal');&#10;  const titleEl = document.getElementById('confirm-title');&#10;  const messageEl = document.getElementById('confirm-message');&#10;  const confirmBtn = document.getElementById('confirm-ok');&#10;  const cancelBtn = document.getElementById('confirm-cancel');&#10;  const iconEl = document.querySelector('.confirm-icon');&#10;&#10;  if (!modal || !titleEl || !messageEl || !confirmBtn || !cancelBtn) return;&#10;&#10;  titleEl.textContent = title;&#10;  messageEl.textContent = message;&#10;&#10;  // Adicionar animação no ícone&#10;  if (iconEl) {&#10;    iconEl.style.animation = 'pulseScale 2s ease-in-out infinite';&#10;  }&#10;&#10;  // Limpar listeners antigos&#10;  const newConfirmBtn = confirmBtn.cloneNode(true);&#10;  const newCancelBtn = cancelBtn.cloneNode(true);&#10;  confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);&#10;  cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);&#10;&#10;  // Adicionar efeitos de hover ao botão cancelar&#10;  newCancelBtn.addEventListener('mouseenter', () =&gt; {&#10;    newCancelBtn.style.background = '#f1f5f9';&#10;    newCancelBtn.style.color = '#475569';&#10;    newCancelBtn.style.transform = 'scale(1.02)';&#10;  });&#10;  newCancelBtn.addEventListener('mouseleave', () =&gt; {&#10;    newCancelBtn.style.background = '#ffffff';&#10;    newCancelBtn.style.color = '#64748b';&#10;    newCancelBtn.style.transform = 'scale(1)';&#10;  });&#10;&#10;  // Adicionar efeitos de hover ao botão confirmar&#10;  newConfirmBtn.addEventListener('mouseenter', () =&gt; {&#10;    newConfirmBtn.style.background = 'linear-gradient(135deg, #dc2626 0%, #b91c1c 100%)';&#10;    newConfirmBtn.style.transform = 'scale(1.02)';&#10;    newConfirmBtn.style.boxShadow = 'inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 8px 24px rgba(239, 68, 68, 0.4)';&#10;  });&#10;  newConfirmBtn.addEventListener('mouseleave', () =&gt; {&#10;    newConfirmBtn.style.background = 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';&#10;    newConfirmBtn.style.transform = 'scale(1)';&#10;    newConfirmBtn.style.boxShadow = 'inset 0 1px 0 rgba(255, 255, 255, 0.2)';&#10;  });&#10;&#10;  // Adicionar novos listeners de click&#10;  newConfirmBtn.addEventListener('click', () =&gt; {&#10;    modal.style.display = 'none';&#10;    if (onConfirm) onConfirm();&#10;  });&#10;&#10;  newCancelBtn.addEventListener('click', () =&gt; {&#10;    modal.style.display = 'none';&#10;    if (onCancel) onCancel();&#10;  });&#10;&#10;  // Fechar ao clicar fora&#10;  modal.addEventListener('click', (e) =&gt; {&#10;    if (e.target === modal) {&#10;      modal.style.display = 'none';&#10;      if (onCancel) onCancel();&#10;    }&#10;  });&#10;&#10;  modal.style.display = 'flex';&#10;}&#10;&#10;// Função global para abrir modal de avaliação&#10;window.openRatingModal = function(bookId, currentStars = 0, currentComment = '', isEditing = false) {&#10;  const userId = localStorage.getItem('user_id');&#10;  const modal = document.getElementById('rating-modal');&#10;  const submitBtn = document.getElementById('submit-rating');&#10;  const cancelBtn = document.getElementById('cancel-rating');&#10;  const commentInput = document.getElementById('rating-comment');&#10;  const ratingText = document.getElementById('rating-text');&#10;  const charCount = document.getElementById('char-count');&#10;  let selectedRating = 0;&#10;&#10;  // Textos descritivos para cada nota&#10;  const ratingDescriptions = {&#10;    1: '⭐ Muito Ruim',&#10;    2: '⭐⭐ Ruim',&#10;    3: '⭐⭐⭐ Regular',&#10;    4: '⭐⭐⭐⭐ Bom',&#10;    5: '⭐⭐⭐⭐⭐ Excelente!'&#10;  };&#10;&#10;  // Reset e preparar modal&#10;  const starContainer = document.querySelector('.star-rating');&#10;  starContainer.innerHTML = `&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;1&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;2&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;3&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;4&quot;&gt;⭐&lt;/span&gt;&#10;    &lt;span class=&quot;star&quot; data-rating=&quot;5&quot;&gt;⭐&lt;/span&gt;&#10;  `;&#10;&#10;  commentInput.value = '';&#10;  ratingText.textContent = 'Selecione uma nota';&#10;  ratingText.classList.remove('has-rating');&#10;  charCount.textContent = '0';&#10;&#10;  // Preencher dados atuais (modo edição)&#10;  if(currentStars &gt; 0){&#10;    selectedRating = currentStars;&#10;    updateStarDisplay(selectedRating, true); // true = usar classe active (amarelo permanente)&#10;    ratingText.textContent = ratingDescriptions[selectedRating];&#10;    ratingText.classList.add('has-rating');&#10;  }&#10;  if(currentComment){&#10;    commentInput.value = currentComment;&#10;    charCount.textContent = currentComment.length;&#10;  }&#10;&#10;  // Função para atualizar display das estrelas&#10;  function updateStarDisplay(rating, useActive = false) {&#10;    const stars = document.querySelectorAll('.star-rating .star');&#10;    stars.forEach((star, i) =&gt; {&#10;      if(i &lt; rating){&#10;        // Estrelas selecionadas: amarelas&#10;        star.style.filter = 'grayscale(0%) brightness(1)';&#10;        star.style.opacity = '1';&#10;        star.style.transform = 'scale(1)';&#10;      } else {&#10;        // Estrelas não selecionadas: cinza&#10;        star.style.filter = 'grayscale(100%) brightness(1.1)';&#10;        star.style.opacity = '0.5';&#10;        star.style.transform = 'scale(1)';&#10;      }&#10;    });&#10;  }&#10;&#10;  // Event listeners para as estrelas&#10;  const stars = document.querySelectorAll('.star');&#10;  stars.forEach(star =&gt; {&#10;    // Hover&#10;    star.addEventListener('mouseenter', function(){&#10;      const rating = parseInt(this.dataset.rating);&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;      allStars.forEach((s, i) =&gt; {&#10;        if(i &lt; rating){&#10;          // Hover: mostrar preview amarelo&#10;          s.style.filter = 'grayscale(0%) brightness(1)';&#10;          s.style.opacity = '1';&#10;          s.style.transform = 'scale(1.15)';&#10;        } else {&#10;          // Manter cinza&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          s.style.transform = 'scale(1)';&#10;        }&#10;      });&#10;      ratingText.textContent = ratingDescriptions[rating];&#10;      ratingText.classList.add('has-rating');&#10;    });&#10;&#10;    // Mouse leave&#10;    star.addEventListener('mouseleave', function(){&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;      if(selectedRating &gt; 0) {&#10;        // Restaurar para o estado selecionado&#10;        allStars.forEach((s, i) =&gt; {&#10;          if(i &lt; selectedRating){&#10;            s.style.filter = 'grayscale(0%) brightness(1)';&#10;            s.style.opacity = '1';&#10;            s.style.transform = 'scale(1)';&#10;          } else {&#10;            s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;            s.style.opacity = '0.5';&#10;            s.style.transform = 'scale(1)';&#10;          }&#10;        });&#10;        ratingText.textContent = ratingDescriptions[selectedRating];&#10;        ratingText.classList.add('has-rating');&#10;      } else {&#10;        // Nenhuma selecionada: todas cinza&#10;        allStars.forEach(s =&gt; {&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          s.style.transform = 'scale(1)';&#10;        });&#10;        ratingText.textContent = 'Selecione uma nota';&#10;        ratingText.classList.remove('has-rating');&#10;      }&#10;    });&#10;&#10;    // Click&#10;    star.addEventListener('click', function(){&#10;      selectedRating = parseInt(this.dataset.rating);&#10;      const allStars = document.querySelectorAll('.star-rating .star');&#10;&#10;      console.log('Clicked star with rating:', selectedRating);&#10;&#10;      allStars.forEach((s, i) =&gt; {&#10;        // Remover todas as classes e estilos primeiro&#10;        s.classList.remove('filled', 'active');&#10;&#10;        if(i &lt; selectedRating){&#10;          // Estrelas selecionadas: amarelas (sem grayscale)&#10;          s.classList.add('active');&#10;          s.style.filter = 'grayscale(0%) brightness(1)';&#10;          s.style.opacity = '1';&#10;          console.log('Star', i, 'set to ACTIVE (yellow)');&#10;        } else {&#10;          // Estrelas não selecionadas: cinza&#10;          s.style.filter = 'grayscale(100%) brightness(1.1)';&#10;          s.style.opacity = '0.5';&#10;          console.log('Star', i, 'set to INACTIVE (gray)');&#10;        }&#10;      });&#10;&#10;      // Animar a estrela clicada&#10;      this.style.animation = 'starPop 0.3s ease-out';&#10;&#10;      ratingText.textContent = ratingDescriptions[selectedRating];&#10;      ratingText.classList.add('has-rating');&#10;&#10;      // Feedback tátil (se disponível)&#10;      if (navigator.vibrate) {&#10;        navigator.vibrate(10);&#10;      }&#10;    });&#10;  });&#10;&#10;  // Contador de caracteres&#10;  commentInput.addEventListener('input', function(){&#10;    charCount.textContent = this.value.length;&#10;  });&#10;&#10;  // Botão de cancelar&#10;  if(cancelBtn) {&#10;    cancelBtn.onclick = () =&gt; {&#10;      modal.style.display = 'none';&#10;      // Reabrir modal de avaliações se estava aberto&#10;      const ratingsModal = document.getElementById('ratings-modal');&#10;      if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;        ratingsModal.style.display = 'flex';&#10;        ratingsModal.dataset.wasOpen = 'false';&#10;      }&#10;    };&#10;  }&#10;&#10;  // Botão de submit&#10;  submitBtn.onclick = () =&gt; {&#10;    if(selectedRating === 0){&#10;      showToast('Por favor, selecione uma nota de 1 a 5 estrelas', 'warning', 'Avaliação incompleta');&#10;      // Animação de shake nas estrelas&#10;      const starRating = document.querySelector('.star-rating');&#10;      starRating.style.animation = 'none';&#10;      setTimeout(() =&gt; {&#10;        starRating.style.animation = 'shake 0.5s';&#10;      }, 10);&#10;      return;&#10;    }&#10;    const comment = commentInput.value.trim();&#10;    window.saveRating(bookId, selectedRating, comment, isEditing);&#10;    modal.style.display = 'none';&#10;  };&#10;&#10;  modal.style.display = 'flex';&#10;};&#10;&#10;// Função global para salvar avaliação&#10;window.saveRating = async function(bookId, stars, comment, reopenRatingsModal = false) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  try{&#10;    const payload = {&#10;      google_books_id: bookId,&#10;      estrelas: stars&#10;    };&#10;    if(comment) payload.comentario = comment;&#10;&#10;    const res = await fetch(`/api/users/${userId}/ratings`, {&#10;      method: 'POST',&#10;      headers: {&#10;        'Content-Type': 'application/json',&#10;        'Authorization': 'Bearer ' + userId&#10;      },&#10;      body: JSON.stringify(payload)&#10;    });&#10;    const data = await res.json();&#10;    if(res.ok) {&#10;      showToast(data.message || 'Avaliação salva com sucesso!', 'success');&#10;      // Só reabrir modal de avaliações se vier da edição&#10;      if(reopenRatingsModal) {&#10;        setTimeout(() =&gt; {&#10;          if(window.showRatings) window.showRatings();&#10;        }, 500);&#10;      }&#10;    } else {&#10;      showToast(data.error || 'Erro ao salvar avaliação', 'error');&#10;    }&#10;  }catch(e){&#10;    showToast('Erro: ' + e.message, 'error');&#10;  }&#10;};&#10;&#10;document.addEventListener('DOMContentLoaded', async ()=&gt;{&#10;  const userId = localStorage.getItem('user_id');&#10;  let isLoggedIn = false;&#10;  let username = '';&#10;&#10;  // Verificar se está logado (mas não redirecionar se não estiver)&#10;  if(userId){&#10;    try{&#10;      const res = await fetch('/auth/me', { headers: { 'Authorization': 'Bearer '+userId }});&#10;      const data = await res.json();&#10;      if(res.ok){&#10;        isLoggedIn = true;&#10;        username = data.username || 'Usuário';&#10;        document.getElementById('username').textContent = username;&#10;      }else{&#10;        localStorage.removeItem('user_id');&#10;        localStorage.removeItem('username');&#10;      }&#10;    }catch(e){&#10;      console.error('Erro ao validar sessão:', e);&#10;      localStorage.removeItem('user_id');&#10;      localStorage.removeItem('username');&#10;    }&#10;  }&#10;&#10;  // Atualizar botão de login/logout&#10;  const btnLogout = document.getElementById('btn-logout');&#10;  const btnLogin = document.getElementById('btn-login');&#10;  const btnFavoritesHeader = document.getElementById('btn-favorites');&#10;  const btnRatingsHeader = document.getElementById('btn-ratings');&#10;&#10;  if(isLoggedIn){&#10;    // Mostrar nome do usuário, botão de sair, favoritos e avaliações&#10;    document.getElementById('user-info').style.display = 'flex';&#10;    if(btnLogin) btnLogin.style.display = 'none';&#10;    if(btnFavoritesHeader) {&#10;      btnFavoritesHeader.style.display = 'block';&#10;      // Adicionar event listener para favoritos&#10;      btnFavoritesHeader.addEventListener('click', () =&gt; window.showFavorites());&#10;    }&#10;    if(btnRatingsHeader) {&#10;      btnRatingsHeader.style.display = 'block';&#10;      btnRatingsHeader.addEventListener('click', () =&gt; window.showRatings());&#10;    }&#10;&#10;    if(btnLogout){&#10;      btnLogout.addEventListener('click', async ()=&gt;{&#10;        try{&#10;          await fetch('/auth/logout', {&#10;            method: 'POST',&#10;            headers: {'Content-Type':'application/json'},&#10;            body: JSON.stringify({user_id: userId})&#10;          });&#10;        }catch(e){&#10;          console.error('Erro ao fazer logout:', e);&#10;        }&#10;        localStorage.removeItem('user_id');&#10;        localStorage.removeItem('username');&#10;        showToast('Você saiu com sucesso!', 'info', 'Até logo!');&#10;        setTimeout(() =&gt; location.reload(), 1000);&#10;      });&#10;    }&#10;  }else{&#10;    // Mostrar botão de login e ocultar favoritos e avaliações&#10;    document.getElementById('user-info').style.display = 'none';&#10;    if(btnFavoritesHeader) btnFavoritesHeader.style.display = 'none';&#10;    if(btnRatingsHeader) btnRatingsHeader.style.display = 'none';&#10;    if(btnLogin){&#10;      btnLogin.style.display = 'block';&#10;      btnLogin.addEventListener('click', ()=&gt; openAuthModal());&#10;    }&#10;  }&#10;&#10;  // Elementos do dashboard&#10;  const searchInput = document.getElementById('search-input');&#10;  const btnSearch = document.getElementById('btn-search');&#10;  const resultsContainer = document.getElementById('results-container');&#10;  const loading = document.getElementById('loading');&#10;  const bookModal = document.getElementById('book-modal');&#10;  const closeModal = document.querySelector('.close-modal');&#10;&#10;  // Variáveis para rastrear de onde o modal foi aberto&#10;  let openedFromFavorites = false;&#10;  let openedFromRatings = false;&#10;&#10;  // Buscar livros&#10;  if(btnSearch &amp;&amp; searchInput){&#10;    btnSearch.addEventListener('click', ()=&gt; searchBooks(searchInput.value.trim()));&#10;    searchInput.addEventListener('keypress', (e)=&gt; {&#10;      if(e.key === 'Enter') searchBooks(searchInput.value.trim());&#10;    });&#10;  }&#10;&#10;  // Fechar modal&#10;  if(closeModal){&#10;    closeModal.addEventListener('click', ()=&gt; {&#10;      bookModal.style.display = 'none';&#10;&#10;      // Se foi aberto dos favoritos, reabre o modal de favoritos&#10;      if (openedFromFavorites) {&#10;        openedFromFavorites = false;&#10;        document.getElementById('favorites-modal').style.display = 'flex';&#10;      }&#10;&#10;      // Se foi aberto das avaliações, reabre o modal de avaliações&#10;      if (openedFromRatings) {&#10;        openedFromRatings = false;&#10;        document.getElementById('ratings-modal').style.display = 'flex';&#10;      }&#10;    });&#10;  }&#10;  if(bookModal){&#10;    bookModal.addEventListener('click', (e)=&gt; {&#10;      if(e.target === bookModal) {&#10;        bookModal.style.display = 'none';&#10;&#10;        // Se foi aberto dos favoritos, reabre o modal de favoritos&#10;        if (openedFromFavorites) {&#10;          openedFromFavorites = false;&#10;          document.getElementById('favorites-modal').style.display = 'flex';&#10;        }&#10;&#10;        // Se foi aberto das avaliações, reabre o modal de avaliações&#10;        if (openedFromRatings) {&#10;          openedFromRatings = false;&#10;          document.getElementById('ratings-modal').style.display = 'flex';&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  // Função buscar livros&#10;  async function searchBooks(query){&#10;    console.log('searchBooks called with query:', query);&#10;&#10;    if(!query){&#10;      showToast('Digite o nome de um livro para buscar', 'warning');&#10;      return;&#10;    }&#10;&#10;    console.log('Mostrando loading...');&#10;    loading.style.display = 'block';&#10;    resultsContainer.innerHTML = '';&#10;&#10;    try{&#10;      console.log('Fazendo fetch para /api/books...');&#10;      const res = await fetch('/api/books', {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': 'Bearer ' + userId&#10;        },&#10;        body: JSON.stringify({ findBook: query })&#10;      });&#10;&#10;      console.log('Response status:', res.status);&#10;      const data = await res.json();&#10;      console.log('Response data:', data);&#10;&#10;      if(!res.ok) throw new Error(data.error || 'Erro ao buscar livros');&#10;&#10;      displayBooks(data);&#10;    }catch(e){&#10;      console.error('Erro na busca:', e);&#10;      resultsContainer.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro na busca&lt;/h3&gt;&#10;          &lt;p&gt;${e.message}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }finally{&#10;      console.log('Escondendo loading...');&#10;      loading.style.display = 'none';&#10;    }&#10;  }&#10;&#10;  // Exibir livros&#10;  function displayBooks(books){&#10;    console.log('displayBooks called with:', books);&#10;&#10;    if(!books || books.length === 0){&#10;      resultsContainer.innerHTML = `&#10;        &lt;div class=&quot;no-results&quot;&gt;&#10;          &lt;div class=&quot;no-results-icon&quot;&gt;&lt;/div&gt;&#10;          &lt;h3&gt;Nenhum livro encontrado&lt;/h3&gt;&#10;          &lt;p&gt;Tente buscar com outros termos&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    console.log('Exibindo', books.length, 'livros');&#10;&#10;    // Criar grid de cards&#10;    const booksHTML = books.map(book =&gt; {&#10;      const thumbnail = book.imageLinks?.thumbnail || book.imageLinks?.smallThumbnail || '';&#10;      const authors = Array.isArray(book.authors) ? book.authors.join(', ') : (book.authors || 'Autor desconhecido');&#10;      const description = book.description || 'Sem descrição disponível';&#10;      const shortDescription = description.length &gt; 120 ? description.substring(0, 120) + '...' : description;&#10;&#10;      // Extrair ano de publicação se existir&#10;      const publishedYear = book.publishedDate ? book.publishedDate.split('-')[0] : '';&#10;&#10;      return `&#10;        &lt;div class=&quot;book-card&quot; onclick=&quot;loadBookDetails('${book.id}')&quot;&gt;&#10;          &lt;div class=&quot;book-thumbnail&quot;&gt;&#10;            ${thumbnail ?&#10;              `&lt;img src=&quot;${thumbnail}&quot; alt=&quot;${book.title}&quot; onerror=&quot;this.onerror=null; this.parentElement.innerHTML='&lt;div class=\\'book-no-cover\\'&gt;&lt;/div&gt;'&quot;&gt;` :&#10;              `&lt;div class=&quot;book-no-cover&quot;&gt;&lt;/div&gt;`&#10;            }&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;book-info&quot;&gt;&#10;            &lt;h3 class=&quot;book-title&quot;&gt;${book.title}&lt;/h3&gt;&#10;            &lt;p class=&quot;book-author&quot;&gt;${authors}&lt;/p&gt;&#10;            ${publishedYear ? `&lt;p class=&quot;book-year&quot;&gt;${publishedYear}&lt;/p&gt;` : ''}&#10;            &lt;p class=&quot;book-description&quot;&gt;${shortDescription}&lt;/p&gt;&#10;            &lt;div class=&quot;book-card-footer&quot;&gt;&#10;              &lt;span class=&quot;book-card-cta&quot;&gt;Ver detalhes →&lt;/span&gt;&#10;            &lt;/div&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;    resultsContainer.innerHTML = `&lt;div class=&quot;books-grid&quot;&gt;${booksHTML}&lt;/div&gt;`;&#10;    console.log('Livros exibidos com sucesso em grid');&#10;  }&#10;&#10;  // Carregar detalhes&#10;  window.loadBookDetails = async function(bookId, fromFavorites = false, fromRatings = false){&#10;    console.log('loadBookDetails called with bookId:', bookId, 'fromFavorites:', fromFavorites, 'fromRatings:', fromRatings);&#10;&#10;    // Definir flags se foi aberto dos favoritos ou avaliações&#10;    openedFromFavorites = fromFavorites;&#10;    openedFromRatings = fromRatings;&#10;&#10;    // Fechar modal de favoritos se estiver aberto&#10;    const favoritesModal = document.getElementById('favorites-modal');&#10;    if (favoritesModal &amp;&amp; favoritesModal.style.display === 'flex') {&#10;      favoritesModal.style.display = 'none';&#10;    }&#10;&#10;    // Fechar modal de avaliações se estiver aberto&#10;    const ratingsModal = document.getElementById('ratings-modal');&#10;    if (ratingsModal &amp;&amp; ratingsModal.style.display === 'flex') {&#10;      ratingsModal.style.display = 'none';&#10;    }&#10;&#10;    const bookDetails = document.getElementById('book-details');&#10;    bookDetails.innerHTML = '&lt;div class=&quot;loading&quot;&gt;&lt;div class=&quot;spinner&quot;&gt;&lt;/div&gt;&lt;p&gt;Carregando...&lt;/p&gt;&lt;/div&gt;';&#10;    bookModal.style.display = 'flex';&#10;&#10;    try{&#10;      console.log('Fetching book details from:', `/api/books/${bookId}`);&#10;      const res = await fetch(`/api/books/${bookId}`, {&#10;        method: 'GET',&#10;        headers: { 'Authorization': 'Bearer ' + userId }&#10;      });&#10;&#10;      console.log('Book details response status:', res.status);&#10;      const data = await res.json();&#10;      console.log('Book details data:', data);&#10;&#10;      if(!res.ok) throw new Error(data.error || 'Erro ao carregar detalhes');&#10;&#10;      // Backend retorna {book: {...}, avaliacoes: [...]}&#10;      // Precisamos mesclar book com avaliacoes&#10;      const bookData = {&#10;        ...data.book,&#10;        avaliacoes: data.avaliacoes || []&#10;      };&#10;&#10;      console.log('Merged book data:', bookData);&#10;      displayBookDetails(bookData);&#10;    }catch(e){&#10;      console.error('Erro ao carregar detalhes:', e);&#10;      bookDetails.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro&lt;/h3&gt;&#10;          &lt;p&gt;${e.message}&lt;/p&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }&#10;  };&#10;&#10;  // Exibir detalhes&#10;  function displayBookDetails(book){&#10;    console.log('displayBookDetails called with:', book);&#10;    console.log('book.title:', book.title);&#10;    console.log('book.authors:', book.authors);&#10;    console.log('book.imageLinks:', book.imageLinks);&#10;&#10;    if(!book || !book.title){&#10;      const bookDetails = document.getElementById('book-details');&#10;      bookDetails.innerHTML = `&#10;        &lt;div class=&quot;error-message&quot;&gt;&#10;          &lt;h3&gt;❌ Erro&lt;/h3&gt;&#10;          &lt;p&gt;Dados do livro inválidos ou incompletos&lt;/p&gt;&#10;          &lt;pre&gt;${JSON.stringify(book, null, 2)}&lt;/pre&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    const bookDetails = document.getElementById('book-details');&#10;    const thumbnail = book.imageLinks?.thumbnail || '';&#10;    const authors = Array.isArray(book.authors) &amp;&amp; book.authors.length &gt; 0&#10;      ? book.authors.join(', ')&#10;      : 'Autor desconhecido';&#10;    const publisher = book.publisher || '';&#10;    const publishedDate = book.publishedDate || '';&#10;    const publisherInfo = [publisher, publishedDate].filter(x =&gt; x).join(' - ');&#10;    const title = book.title || 'Título não disponível';&#10;    const description = book.description || 'Sem descrição disponível.';&#10;&#10;    bookDetails.innerHTML = `&#10;      &lt;div class=&quot;book-detail-header&quot;&gt;&#10;        ${thumbnail ?&#10;          `&lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.style.display='none'&quot;&gt;` :&#10;          `&lt;div class=&quot;book-no-image&quot;&gt;&lt;/div&gt;`&#10;        }&#10;        &lt;div&gt;&#10;          &lt;h2&gt;${title}&lt;/h2&gt;&#10;          &lt;p class=&quot;author&quot;&gt;${authors}&lt;/p&gt;&#10;          ${publisherInfo ? `&lt;p class=&quot;publisher&quot;&gt;${publisherInfo}&lt;/p&gt;` : ''}&#10;          ${book.pageCount ? `&lt;p class=&quot;pages&quot;&gt; ${book.pageCount} páginas&lt;/p&gt;` : ''}&#10;          ${book.language ? `&lt;p class=&quot;language&quot;&gt; Idioma: ${book.language.toUpperCase()}&lt;/p&gt;` : ''}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;      &lt;div class=&quot;book-detail-body&quot;&gt;&#10;        &lt;h3&gt; Descrição&lt;/h3&gt;&#10;        &lt;p&gt;${description}&lt;/p&gt;&#10;&#10;        ${book.categories &amp;&amp; book.categories.length &gt; 0 ? `&#10;          &lt;h3&gt;️ Categorias&lt;/h3&gt;&#10;          &lt;p&gt;${book.categories.join(', ')}&lt;/p&gt;&#10;        ` : ''}&#10;&#10;        ${book.avaliacoes &amp;&amp; book.avaliacoes.length &gt; 0 ? `&#10;          &lt;h3&gt;⭐ Avaliações&lt;/h3&gt;&#10;          &lt;div class=&quot;avaliacoes&quot;&gt;&#10;            ${book.avaliacoes.map(av =&gt; `&#10;              &lt;div class=&quot;avaliacao&quot;&gt;&#10;                &lt;strong&gt;${av.usuario_nome}&lt;/strong&gt; - ${'⭐'.repeat(av.estrelas)}&#10;                ${av.comentario ? `&lt;p&gt;${av.comentario}&lt;/p&gt;` : ''}&#10;                &lt;small&gt;${new Date(av.data_avaliacao).toLocaleDateString('pt-BR')}&lt;/small&gt;&#10;              &lt;/div&gt;&#10;            `).join('')}&#10;          &lt;/div&gt;&#10;        ` : ''}&#10;&#10;        &lt;div class=&quot;book-actions&quot;&gt;&#10;          &lt;button class=&quot;btn-primary&quot; onclick=&quot;addToFavorites('${book.id}')&quot;&gt;❤️ Favoritar&lt;/button&gt;&#10;          &lt;button class=&quot;btn-secondary&quot; onclick=&quot;rateBook('${book.id}')&quot;&gt;⭐ Avaliar&lt;/button&gt;&#10;          ${book.previewLink ? `&lt;a href=&quot;${book.previewLink}&quot; target=&quot;_blank&quot; class=&quot;btn-link&quot;&gt;️ Prévia&lt;/a&gt;` : ''}&#10;          ${book.infoLink ? `&lt;a href=&quot;${book.infoLink}&quot; target=&quot;_blank&quot; class=&quot;btn-link&quot;&gt;ℹ️ Mais informações&lt;/a&gt;` : ''}&#10;        &lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;    console.log('Book details displayed successfully');&#10;  }&#10;&#10;  // Adicionar aos favoritos&#10;  window.addToFavorites = async function(bookId){&#10;    if(!isLoggedIn){&#10;      showToast('Faça login para adicionar livros aos favoritos', 'warning', 'Login necessário');&#10;      setTimeout(() =&gt; openAuthModal('login'), 500);&#10;      return;&#10;    }&#10;    try{&#10;      const res = await fetch(`/api/users/${userId}/favorites`, {&#10;        method: 'POST',&#10;        headers: {&#10;          'Content-Type': 'application/json',&#10;          'Authorization': 'Bearer ' + userId&#10;        },&#10;        body: JSON.stringify({ book_id: bookId })&#10;      });&#10;      const data = await res.json();&#10;      if(res.ok) showToast('Livro adicionado aos favoritos!', 'success');&#10;      else showToast(data.error || 'Erro ao adicionar favorito', 'error');&#10;    }catch(e){&#10;      showToast('Erro: ' + e.message, 'error');&#10;    }&#10;  };&#10;&#10;  // Avaliar livro&#10;  window.rateBook = async function(bookId){&#10;    if(!isLoggedIn){&#10;      showToast('Faça login para avaliar livros', 'warning', 'Login necessário');&#10;      setTimeout(() =&gt; openAuthModal('login'), 500);&#10;      return;&#10;    }&#10;&#10;    // Verificar se o usuário já avaliou este livro&#10;    try {&#10;      const res = await fetch(`/api/ratings/${bookId}/check?user_id=${userId}`);&#10;      const data = await res.json();&#10;&#10;      if(res.ok &amp;&amp; data.ja_avaliou) {&#10;        showToast('Livro já avaliado! Acesse &quot;Minhas Avaliações&quot; para editar sua avaliação.', 'info', 'Já avaliado');&#10;        return;&#10;      }&#10;    } catch(e) {&#10;      console.error('Erro ao verificar avaliação:', e);&#10;      // Se der erro na verificação, continua e deixa abrir o modal&#10;    }&#10;&#10;    window.openRatingModal(bookId);&#10;  };&#10;&#10;  // Gerenciar fechamento do modal de rating&#10;  const ratingModal = document.getElementById('rating-modal');&#10;  const closeRatingModal = document.getElementById('close-rating-modal');&#10;&#10;  if(closeRatingModal){&#10;    closeRatingModal.addEventListener('click', ()=&gt; {&#10;      ratingModal.style.display = 'none';&#10;      // Reabrir modal de avaliações se estava aberto&#10;      const ratingsModal = document.getElementById('ratings-modal');&#10;      if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;        ratingsModal.style.display = 'flex';&#10;        ratingsModal.dataset.wasOpen = 'false';&#10;      }&#10;    });&#10;  }&#10;&#10;  // Fechar ao clicar fora do modal&#10;  if(ratingModal){&#10;    ratingModal.addEventListener('click', (e)=&gt; {&#10;      if(e.target === ratingModal) {&#10;        ratingModal.style.display = 'none';&#10;        // Reabrir modal de avaliações se estava aberto&#10;        const ratingsModal = document.getElementById('ratings-modal');&#10;        if(ratingsModal &amp;&amp; ratingsModal.dataset.wasOpen === 'true') {&#10;          ratingsModal.style.display = 'flex';&#10;          ratingsModal.dataset.wasOpen = 'false';&#10;        }&#10;      }&#10;    });&#10;  }&#10;&#10;  // Modal de autenticação&#10;  const authModal = document.getElementById('auth-modal');&#10;  const authClose = document.querySelector('.auth-close');&#10;&#10;  if(authClose){&#10;    authClose.addEventListener('click', ()=&gt; authModal.style.display = 'none');&#10;  }&#10;&#10;  window.openAuthModal = function(mode = 'login'){&#10;    const loginForm = document.getElementById('login-form-container');&#10;    const registerForm = document.getElementById('register-form-container');&#10;&#10;    if(mode === 'login'){&#10;      loginForm.style.display = 'block';&#10;      registerForm.style.display = 'none';&#10;    }else{&#10;      loginForm.style.display = 'none';&#10;      registerForm.style.display = 'block';&#10;    }&#10;&#10;    authModal.style.display = 'flex';&#10;  };&#10;&#10;  window.switchToRegister = function(){&#10;    document.getElementById('login-form-container').style.display = 'none';&#10;    document.getElementById('register-form-container').style.display = 'block';&#10;  };&#10;&#10;  window.switchToLogin = function(){&#10;    document.getElementById('register-form-container').style.display = 'none';&#10;    document.getElementById('login-form-container').style.display = 'block';&#10;  };&#10;&#10;  // Login&#10;  const loginForm = document.getElementById('login-form');&#10;  if(loginForm){&#10;    loginForm.addEventListener('submit', async (e)=&gt;{&#10;      e.preventDefault();&#10;      const username = document.getElementById('login-username').value;&#10;      const password = document.getElementById('login-password').value;&#10;&#10;      try{&#10;        const res = await fetch('/auth/login', {&#10;          method: 'POST',&#10;          headers: {'Content-Type':'application/json'},&#10;          body: JSON.stringify({username, password})&#10;        });&#10;        const data = await res.json();&#10;&#10;        if(res.ok){&#10;          localStorage.setItem('user_id', data.user_id);&#10;          localStorage.setItem('username', data.username);&#10;          showToast(`Bem-vindo(a), ${data.username}!`, 'success', 'Login realizado!');&#10;          setTimeout(() =&gt; location.reload(), 1000);&#10;        }else{&#10;          showToast(data.error || 'Falha no login', 'error');&#10;        }&#10;      }catch(e){&#10;        showToast('Erro: ' + e.message, 'error');&#10;      }&#10;    });&#10;  }&#10;&#10;  // Registro&#10;  const registerForm = document.getElementById('register-form');&#10;  if(registerForm){&#10;    registerForm.addEventListener('submit', async (e)=&gt;{&#10;      e.preventDefault();&#10;      const username = document.getElementById('register-username').value;&#10;      const email = document.getElementById('register-email').value;&#10;      const password = document.getElementById('register-password').value;&#10;&#10;      try{&#10;        const res = await fetch('/auth/register', {&#10;          method: 'POST',&#10;          headers: {'Content-Type':'application/json'},&#10;          body: JSON.stringify({username, email, password})&#10;        });&#10;        const data = await res.json();&#10;&#10;        if(res.status === 201){&#10;          showToast('✅ Cadastro realizado com sucesso!', 'success');&#10;          &#10;          // Limpar campos&#10;          document.getElementById('register-username').value = '';&#10;          document.getElementById('register-email').value = '';&#10;          document.getElementById('register-password').value = '';&#10;          &#10;          // Mudar para formulário de login após 1.5s&#10;          setTimeout(() =&gt; {&#10;            window.switchToLogin();&#10;          }, 1500);&#10;        }else{&#10;          showToast(data.error || 'Falha no cadastro', 'error');&#10;        }&#10;      }catch(e){&#10;        showToast('Erro: ' + e.message, 'error');&#10;      }&#10;    });&#10;  }&#10;&#10;  // Fechar modal de favoritos&#10;  const favoritesClose = document.querySelector('.favorites-close');&#10;  if(favoritesClose){&#10;    favoritesClose.addEventListener('click', ()=&gt;{&#10;      document.getElementById('favorites-modal').style.display = 'none';&#10;    });&#10;  }&#10;&#10;  // Fechar modal de avaliações&#10;  const ratingsClose = document.querySelector('.ratings-close');&#10;  if(ratingsClose){&#10;    ratingsClose.addEventListener('click', ()=&gt;{&#10;      document.getElementById('ratings-modal').style.display = 'none';&#10;    });&#10;  }&#10;&#10;  // Os event listeners dos botões de favoritos e avaliações agora são&#10;  // adicionados dentro do bloco de login (linhas 72-83)&#10;&#10;  // Fechar modais ao clicar fora&#10;  window.addEventListener('click', (e) =&gt; {&#10;    const bookModal = document.getElementById('book-modal');&#10;    const authModal = document.getElementById('auth-modal');&#10;    const favoritesModal = document.getElementById('favorites-modal');&#10;    const ratingsModal = document.getElementById('ratings-modal');&#10;&#10;    if (e.target === bookModal) {&#10;      bookModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === authModal) {&#10;      authModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === favoritesModal) {&#10;      favoritesModal.style.display = 'none';&#10;    }&#10;&#10;    if (e.target === ratingsModal) {&#10;      ratingsModal.style.display = 'none';&#10;    }&#10;  });&#10;});&#10;&#10;// Função para mostrar favoritos&#10;window.showFavorites = async function() {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    openAuthModal();&#10;    return;&#10;  }&#10;&#10;  const modal = document.getElementById('favorites-modal');&#10;  const content = document.getElementById('favorites-content');&#10;&#10;  content.innerHTML = '&lt;p style=&quot;text-align: center; padding: 40px;&quot;&gt;Carregando favoritos...&lt;/p&gt;';&#10;  modal.style.display = 'flex';&#10;&#10;  try {&#10;    const res = await fetch(`/api/users/${userId}/favorites`);&#10;    const data = await res.json();&#10;&#10;    if (!res.ok) {&#10;      throw new Error(data.error || 'Erro ao carregar favoritos');&#10;    }&#10;&#10;    if (!data.favorite_books || data.favorite_books.length === 0) {&#10;      content.innerHTML = `&#10;        &lt;div class=&quot;no-favorites&quot;&gt;&#10;          &lt;div class=&quot;no-favorites-icon&quot;&gt;&lt;/div&gt;&#10;          &lt;div class=&quot;no-favorites-text&quot;&gt;Nenhum livro favorito ainda&lt;/div&gt;&#10;          &lt;div class=&quot;no-favorites-subtext&quot;&gt;Explore livros e adicione aos seus favoritos!&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    // Buscar detalhes de cada livro favorito&#10;    const bookPromises = data.favorite_books.map(bookId =&gt;&#10;      fetch(`/api/books/${bookId}`).then(r =&gt; r.json())&#10;    );&#10;&#10;    const books = await Promise.all(bookPromises);&#10;&#10;    content.innerHTML = books.map(book =&gt; {&#10;      const bookData = book.book || book;&#10;      const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || '/static/img/book-placeholder.png';&#10;      const title = bookData.title || 'Título desconhecido';&#10;      const authors = bookData.authors ? bookData.authors.join(', ') : 'Autor desconhecido';&#10;&#10;      return `&#10;        &lt;div class=&quot;favorite-item&quot; onclick=&quot;loadBookDetails('${bookData.id}', true)&quot;&gt;&#10;          &lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.src='/static/img/book-placeholder.png'&quot;&gt;&#10;          &lt;div class=&quot;favorite-item-title&quot;&gt;${title}&lt;/div&gt;&#10;          &lt;div class=&quot;favorite-item-author&quot;&gt;${authors}&lt;/div&gt;&#10;          &lt;div class=&quot;favorite-item-actions&quot; onclick=&quot;event.stopPropagation()&quot;&gt;&#10;            &lt;button class=&quot;btn-remove-favorite&quot; onclick=&quot;removeFavorite('${bookData.id}')&quot;&gt;️ Remover&lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;  } catch (error) {&#10;    console.error('Erro ao carregar favoritos:', error);&#10;    content.innerHTML = `&#10;      &lt;div class=&quot;no-favorites&quot;&gt;&#10;        &lt;div class=&quot;no-favorites-icon&quot;&gt;⚠️&lt;/div&gt;&#10;        &lt;div class=&quot;no-favorites-text&quot;&gt;Erro ao carregar favoritos&lt;/div&gt;&#10;        &lt;div class=&quot;no-favorites-subtext&quot;&gt;${error.message}&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;  }&#10;}&#10;&#10;// Função para remover favorito&#10;async function removeFavorite(bookId) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  showConfirm(&#10;    'Remover dos Favoritos',&#10;    'Tem certeza que deseja remover este livro dos seus favoritos?',&#10;    async () =&gt; {&#10;      try {&#10;        const res = await fetch(`/api/users/${userId}/favorites/${bookId}`, {&#10;          method: 'DELETE'&#10;        });&#10;&#10;        const data = await res.json();&#10;&#10;        if (res.ok) {&#10;          showToast('Livro removido dos favoritos!', 'success', 'Removido!');&#10;          window.showFavorites(); // Recarregar lista&#10;        } else {&#10;          showToast(data.error || 'Erro ao remover favorito', 'error');&#10;        }&#10;      } catch (error) {&#10;        console.error('Erro ao remover favorito:', error);&#10;        showToast('Erro ao remover favorito: ' + error.message, 'error');&#10;      }&#10;    }&#10;  );&#10;}&#10;&#10;// Função para mostrar avaliações&#10;// Função para mostrar avaliações&#10;window.showRatings = async function() {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    openAuthModal();&#10;    return;&#10;  }&#10;&#10;  const ratingsModal = document.getElementById('ratings-modal');&#10;  const ratingsList = document.getElementById('ratings-list');&#10;&#10;  ratingsList.innerHTML = '&lt;p style=&quot;text-align: center; padding: 40px;&quot;&gt;Carregando avaliações...&lt;/p&gt;';&#10;&#10;  ratingsModal.style.display = 'flex';&#10;&#10;  try {&#10;    const res = await fetch(`/api/ratings/user/${userId}`);&#10;    const data = await res.json();&#10;&#10;    if (!res.ok) {&#10;      throw new Error(data.error || 'Erro ao carregar avaliações');&#10;    }&#10;&#10;    if (!data.ratings || data.ratings.length === 0) {&#10;      ratingsList.innerHTML = `&#10;        &lt;div class=&quot;no-ratings&quot;&gt;&#10;          &lt;div class=&quot;no-ratings-icon&quot;&gt;⭐&lt;/div&gt;&#10;          &lt;div class=&quot;no-ratings-text&quot;&gt;Nenhuma avaliação ainda&lt;/div&gt;&#10;          &lt;div class=&quot;no-ratings-subtext&quot;&gt;Avalie livros para aparecerem aqui!&lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;      return;&#10;    }&#10;&#10;    // Buscar detalhes de cada livro avaliado&#10;    const bookPromises = data.ratings.map(rating =&gt;&#10;      fetch(`/api/books/${rating.google_books_id}`).then(r =&gt; r.json())&#10;    );&#10;&#10;    const books = await Promise.all(bookPromises);&#10;&#10;    ratingsList.innerHTML = data.ratings.map((rating, index) =&gt; {&#10;      const book = books[index];&#10;      const bookData = book.book || book;&#10;      const thumbnail = bookData.imageLinks?.thumbnail || bookData.imageLinks?.smallThumbnail || '/static/img/book-placeholder.png';&#10;      const title = bookData.title || 'Título desconhecido';&#10;      const authors = bookData.authors ? bookData.authors.join(', ') : 'Autor desconhecido';&#10;      const dataAvaliacao = new Date(rating.data_avaliacao).toLocaleDateString('pt-BR');&#10;&#10;      // Gerar estrelas preenchidas e vazias&#10;      let starsHtml = '';&#10;      for (let i = 1; i &lt;= 5; i++) {&#10;        if (i &lt;= rating.estrelas) {&#10;          starsHtml += '&lt;span class=&quot;star filled&quot;&gt;⭐&lt;/span&gt;';&#10;        } else {&#10;          starsHtml += '&lt;span class=&quot;star empty&quot;&gt;☆&lt;/span&gt;';&#10;        }&#10;      }&#10;&#10;      return `&#10;        &lt;div class=&quot;rating-item&quot; onclick=&quot;loadBookDetails('${bookData.id}', false, true)&quot;&gt;&#10;          &lt;div class=&quot;rating-item-image&quot;&gt;&#10;            &lt;img src=&quot;${thumbnail}&quot; alt=&quot;${title}&quot; onerror=&quot;this.src='/static/img/book-placeholder.png'&quot;&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;rating-item-info&quot;&gt;&#10;            &lt;h3 class=&quot;rating-item-title&quot;&gt;${title}&lt;/h3&gt;&#10;            &lt;div class=&quot;rating-item-author&quot;&gt;${authors}&lt;/div&gt;&#10;            &lt;div class=&quot;rating-stars&quot;&gt;&#10;              ${starsHtml}&#10;              &lt;span style=&quot;margin-left: 8px; color: #6b7280;&quot;&gt;(${rating.estrelas}/5)&lt;/span&gt;&#10;            &lt;/div&gt;&#10;            ${rating.comentario ? `&lt;div class=&quot;rating-item-comment&quot;&gt;&quot;${rating.comentario}&quot;&lt;/div&gt;` : ''}&#10;            &lt;div class=&quot;rating-item-date&quot;&gt;Avaliado em: ${dataAvaliacao}&lt;/div&gt;&#10;          &lt;/div&gt;&#10;          &lt;div class=&quot;rating-item-actions&quot; onclick=&quot;event.stopPropagation()&quot;&gt;&#10;            &lt;button class=&quot;btn-edit-rating&quot; onclick=&quot;editRating('${rating.google_books_id}', ${rating.estrelas}, '${rating.comentario ? rating.comentario.replace(/'/g, &quot;\\'&quot;) : ''}')&quot;&gt;✏️ Editar&lt;/button&gt;&#10;            &lt;button class=&quot;btn-delete-rating&quot; onclick=&quot;deleteRating('${rating.google_books_id}')&quot;&gt;️ Remover&lt;/button&gt;&#10;          &lt;/div&gt;&#10;        &lt;/div&gt;&#10;      `;&#10;    }).join('');&#10;&#10;  } catch (error) {&#10;    console.error('Erro ao carregar avaliações:', error);&#10;    ratingsList.innerHTML = `&#10;      &lt;div class=&quot;no-ratings&quot;&gt;&#10;        &lt;div class=&quot;no-ratings-icon&quot;&gt;⚠️&lt;/div&gt;&#10;        &lt;div class=&quot;no-ratings-text&quot;&gt;Erro ao carregar avaliações&lt;/div&gt;&#10;        &lt;div class=&quot;no-ratings-subtext&quot;&gt;${error.message}&lt;/div&gt;&#10;      &lt;/div&gt;&#10;    `;&#10;  }&#10;}&#10;&#10;// Função para editar avaliação&#10;window.editRating = async function(bookId, currentStars, currentComment) {&#10;  // Fechar modal de avaliações se estiver aberto&#10;  const ratingsModal = document.getElementById('ratings-modal');&#10;  if (ratingsModal &amp;&amp; ratingsModal.style.display === 'flex') {&#10;    ratingsModal.dataset.wasOpen = 'true';&#10;    ratingsModal.style.display = 'none';&#10;  }&#10;&#10;  // Passar true para isEditing para reabrir modal de avaliações após salvar&#10;  window.openRatingModal(bookId, currentStars, currentComment, true);&#10;};&#10;&#10;// Função para deletar avaliação&#10;window.deleteRating = async function(bookId) {&#10;  const userId = localStorage.getItem('user_id');&#10;&#10;  if (!userId) {&#10;    showToast('Você precisa estar logado para remover avaliações', 'error');&#10;    return;&#10;  }&#10;&#10;  showConfirm(&#10;    'Remover Avaliação',&#10;    'Tem certeza que deseja remover esta avaliação?',&#10;    async () =&gt; {&#10;      try {&#10;        const res = await fetch(`/api/ratings/${bookId}?user_id=${userId}`, {&#10;          method: 'DELETE'&#10;        });&#10;&#10;        const data = await res.json();&#10;&#10;        if (res.ok) {&#10;          showToast('Avaliação removida com sucesso!', 'success', 'Removido!');&#10;          window.showRatings(); // Recarregar lista&#10;        } else {&#10;          showToast(data.error || 'Erro ao remover avaliação', 'error');&#10;        }&#10;      } catch (error) {&#10;        console.error('Erro ao remover avaliação:', error);&#10;        showToast('Erro ao remover avaliação: ' + error.message, 'error');&#10;      }&#10;    }&#10;  );&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>