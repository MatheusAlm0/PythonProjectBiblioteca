<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/TESTE_DESIGN.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TESTE_DESIGN.md" />
              <option name="updatedContent" value="#  Guia de Testes - Design Profissional&#10;&#10;## Checklist de Testes para Validar as Melhorias&#10;&#10;Use este guia para testar todas as melhorias de design implementadas.&#10;&#10;---&#10;&#10;##  Teste Visual por Tela&#10;&#10;### 1. ✅ Tela de Login/Registro&#10;&#10;**O que testar:**&#10;- [ ] Background com gradiente roxo está visível&#10;- [ ] Efeito pulsante no background está animando&#10;- [ ] Logo está flutuando (movimento suave para cima e para baixo)&#10;- [ ] Card aparece com animação slideUp&#10;- [ ] Tabs mudam de cor ao clicar&#10;- [ ] Inputs têm borda azul ao focar&#10;- [ ] Botão tem efeito de brilho ao passar o mouse&#10;- [ ] Card tem efeito de vidro fosco (glassmorphism)&#10;&#10;**Como testar:**&#10;1. Acesse `/login` ou a página de login&#10;2. Observe o background animado&#10;3. Passe o mouse sobre inputs e botões&#10;4. Clique nas tabs para alternar&#10;5. Foque nos inputs (clique neles)&#10;&#10;---&#10;&#10;### 2. ✅ Dashboard Header&#10;&#10;**O que testar:**&#10;- [ ] Header com gradiente roxo está visível&#10;- [ ] Ícone de livro no título está presente&#10;- [ ] Botão &quot;Meus Favoritos&quot; tem coração pulsante&#10;- [ ] Botão &quot;Minhas Avaliações&quot; tem estrela rotacionando&#10;- [ ] Botões do header têm efeito glassmorphism&#10;- [ ] Barra de busca tem sombra grande&#10;- [ ] Input de busca muda ao focar&#10;&#10;**Como testar:**&#10;1. Acesse o dashboard principal&#10;2. Observe o header e seus botões&#10;3. Passe o mouse sobre cada botão&#10;4. Clique no input de busca&#10;&#10;---&#10;&#10;### 3. ✅ Cards de Livros&#10;&#10;**O que testar:**&#10;- [ ] Cards têm barra colorida no topo (aparece ao hover)&#10;- [ ] Card sobe ao passar o mouse (translateY)&#10;- [ ] Imagem do livro dá zoom ao hover&#10;- [ ] Título muda de cor ao hover&#10;- [ ] Autor tem ícone de caneta (✍️)&#10;- [ ] Ano tem ícone de calendário () e badge arredondado&#10;- [ ] Botão &quot;Ver detalhes&quot; tem fundo colorido&#10;- [ ] Seta do botão se move ao hover&#10;&#10;**Como testar:**&#10;1. Faça uma busca por livros&#10;2. Passe o mouse sobre cada card&#10;3. Observe todos os efeitos visuais&#10;4. Verifique os ícones emoji&#10;&#10;---&#10;&#10;### 4. ✅ Modal de Favoritos&#10;&#10;**O que testar:**&#10;- [ ] Botão &quot;Meus Favoritos&quot; tem coração animado&#10;- [ ] Modal abre com animação&#10;- [ ] Título tem gradiente de texto rosa&#10;- [ ] Linha decorativa abaixo do título&#10;- [ ] Cards têm barra colorida no topo (aparece ao hover)&#10;- [ ] Imagens dão zoom ao hover&#10;- [ ] Botão remover muda de cor ao hover&#10;&#10;**Como testar:**&#10;1. Clique em &quot;Meus Favoritos&quot;&#10;2. Passe o mouse sobre os cards&#10;3. Observe as animações&#10;4. Clique para fechar o modal&#10;&#10;---&#10;&#10;### 5. ✅ Sistema de Avaliações&#10;&#10;**O que testar:**&#10;- [ ] Botão &quot;Minhas Avaliações&quot; tem estrela rotacionando&#10;- [ ] Modal abre com animação&#10;- [ ] Título tem gradiente de texto laranja&#10;- [ ] Linha decorativa abaixo do título&#10;- [ ] Cards de avaliação têm barra colorida no topo&#10;- [ ] Estrelas estão visíveis e coloridas&#10;- [ ] Botões &quot;Editar&quot; e &quot;Remover&quot; mudam ao hover&#10;&#10;**Como testar:**&#10;1. Clique em &quot;Minhas Avaliações&quot;&#10;2. Observe o modal e seus cards&#10;3. Passe o mouse sobre elementos&#10;4. Teste os botões de ação&#10;&#10;**Modal de Criar Avaliação:**&#10;- [ ] Header com gradiente roxo&#10;- [ ] Ícone flutuante animado&#10;- [ ] Estrelas ficam amarelas ao hover&#10;- [ ] Estrelas ficam fixas ao clicar&#10;- [ ] Texto muda conforme a nota&#10;- [ ] Input de comentário tem foco elegante&#10;- [ ] Botões têm hover effects&#10;&#10;**Como testar:**&#10;1. Abra um livro e clique em &quot;Avaliar&quot;&#10;2. Passe o mouse sobre as estrelas&#10;3. Clique em uma estrela&#10;4. Digite um comentário&#10;5. Observe todos os efeitos&#10;&#10;---&#10;&#10;### 6. ✅ Toasts (Notificações)&#10;&#10;**O que testar:**&#10;- [ ] Toast aparece da direita com bounce&#10;- [ ] Ícone tem animação de bounce e rotação&#10;- [ ] Barra de progresso se move&#10;- [ ] Toast desaparece após 4 segundos&#10;- [ ] Botão fechar rota ao hover&#10;- [ ] Cores diferentes por tipo (success, error, warning, info)&#10;- [ ] Sombra grande ao redor do toast&#10;&#10;**Como testar:**&#10;1. Faça ações que geram toasts (login, adicionar favorito, etc.)&#10;2. Observe a entrada do toast&#10;3. Veja a barra de progresso&#10;4. Passe o mouse no botão fechar&#10;5. Teste diferentes tipos de toasts&#10;&#10;---&#10;&#10;### 7. ✅ Chatbot&#10;&#10;**O que testar:**&#10;- [ ] Botão flutuante tem efeito pulse (ondas)&#10;- [ ] Botão está flutuando (movimento sutil)&#10;- [ ] Botão aumenta ao hover&#10;- [ ] Modal do chatbot é maior (420x650px)&#10;- [ ] Header tem efeito pulsante no background&#10;- [ ] Avatar tem efeito glassmorphism&#10;- [ ] Mensagens aparecem com animação&#10;- [ ] Input tem foco elegante&#10;&#10;**Como testar:**&#10;1. Observe o botão flutuante no canto direito&#10;2. Veja o efeito pulse (ondas ao redor)&#10;3. Passe o mouse sobre o botão&#10;4. Clique para abrir o chatbot&#10;5. Envie uma mensagem&#10;6. Observe as animações&#10;&#10;---&#10;&#10;##  Elementos Visuais para Verificar&#10;&#10;### Cores&#10;```&#10;✅ Roxo/Indigo (#4f46e5) - Primário&#10;✅ Cyan (#06b6d4) - Secundário&#10;✅ Âmbar (#f59e0b) - Accent&#10;✅ Rosa (#ec4899) - Favoritos&#10;✅ Laranja (#f59e0b) - Avaliações&#10;```&#10;&#10;### Animações&#10;```&#10;✅ Pulsante - Background e botões&#10;✅ Flutuante - Logo e botão chatbot&#10;✅ SlideUp - Modais&#10;✅ Bounce - Toasts e ícones&#10;✅ Transform - Hover em cards&#10;✅ Zoom - Imagens&#10;✅ Rotate - Botão fechar&#10;```&#10;&#10;### Efeitos&#10;```&#10;✅ Glassmorphism - Auth card, botões header&#10;✅ Gradientes - Botões, backgrounds, textos&#10;✅ Sombras - Variando de sm a xl&#10;✅ Bordas arredondadas - 8px, 16px, 24px&#10;```&#10;&#10;---&#10;&#10;##  Teste de Responsividade&#10;&#10;### Desktop (&gt; 1024px)&#10;- [ ] Layout em duas colunas (login)&#10;- [ ] Cards em grid com múltiplas colunas&#10;- [ ] Header com todos elementos visíveis&#10;- [ ] Modais centralizados&#10;&#10;### Tablet (768px - 1024px)&#10;- [ ] Layout adaptativo&#10;- [ ] Cards em menos colunas&#10;- [ ] Header ainda legível&#10;- [ ] Modais ajustados&#10;&#10;### Mobile (&lt; 768px)&#10;- [ ] Layout em uma coluna&#10;- [ ] Cards menores&#10;- [ ] Header responsivo&#10;- [ ] Modais full-screen&#10;- [ ] Botões tocáveis (min 44px)&#10;&#10;**Como testar:**&#10;1. Abra as DevTools do navegador (F12)&#10;2. Clique no ícone de dispositivo móvel&#10;3. Teste em diferentes resoluções&#10;4. Verifique todos os breakpoints&#10;&#10;---&#10;&#10;##  Teste de Navegadores&#10;&#10;Teste em:&#10;- [ ] Chrome/Edge (Chromium)&#10;- [ ] Firefox&#10;- [ ] Safari (se disponível)&#10;&#10;**O que verificar:**&#10;- Animações funcionam&#10;- Gradientes aparecem&#10;- Glassmorphism funciona&#10;- Sombras estão visíveis&#10;- Fontes carregam corretamente&#10;&#10;---&#10;&#10;## ⚡ Teste de Performance&#10;&#10;### Animações&#10;- [ ] Transições são suaves (60fps)&#10;- [ ] Sem lag ao hover&#10;- [ ] Animações não travam&#10;&#10;### Loading&#10;- [ ] Spinners aparecem durante loading&#10;- [ ] Estados de loading são claros&#10;- [ ] Feedback visual sempre presente&#10;&#10;---&#10;&#10;##  Problemas Comuns e Soluções&#10;&#10;### Animações não aparecem&#10;**Solução:** Limpe o cache (Ctrl+F5)&#10;&#10;### Cores diferentes do esperado&#10;**Solução:** Verifique se main.css está carregando&#10;&#10;### Glassmorphism não funciona&#10;**Solução:** Use navegador moderno (Chrome 76+, Firefox 70+)&#10;&#10;### Sombras não visíveis&#10;**Solução:** Verifique CSS custom properties&#10;&#10;---&#10;&#10;## ✅ Checklist Final&#10;&#10;Antes de considerar pronto, verifique:&#10;&#10;### Visual&#10;- [ ] Todas cores estão corretas&#10;- [ ] Gradientes aparecem&#10;- [ ] Sombras são visíveis&#10;- [ ] Bordas arredondadas consistentes&#10;- [ ] Tipografia hierárquica&#10;&#10;### Animações&#10;- [ ] Hover effects funcionam&#10;- [ ] Transições são suaves&#10;- [ ] Nenhuma animação está quebrada&#10;- [ ] Performance é boa&#10;&#10;### Funcionalidade&#10;- [ ] Todos botões funcionam&#10;- [ ] Modais abrem/fecham&#10;- [ ] Forms submetem corretamente&#10;- [ ] Toasts aparecem nas ações&#10;&#10;### Responsividade&#10;- [ ] Desktop funciona bem&#10;- [ ] Tablet está adaptado&#10;- [ ] Mobile está otimizado&#10;- [ ] Touch funciona em mobile&#10;&#10;### Acessibilidade&#10;- [ ] Focus states visíveis&#10;- [ ] Contraste adequado&#10;- [ ] Textos legíveis&#10;- [ ] Botões têm tamanho mínimo&#10;&#10;---&#10;&#10;##  Critérios de Sucesso&#10;&#10;O design está pronto quando:&#10;&#10;✅ **Visual:** Parece profissional e moderno&#10;✅ **Consistência:** Todos elementos seguem mesmo padrão&#10;✅ **Animações:** Suaves e naturais&#10;✅ **Responsivo:** Funciona em todos dispositivos&#10;✅ **Performance:** Sem lag ou travamentos&#10;✅ **Acessível:** Todos podem usar&#10;✅ **Funcional:** Tudo funciona como esperado&#10;&#10;---&#10;&#10;##  Após os Testes&#10;&#10;Se tudo estiver OK:&#10;1. ✅ Commit das mudanças&#10;2. ✅ Deploy para produção&#10;3. ✅ Monitorar feedback dos usuários&#10;4. ✅ Fazer ajustes se necessário&#10;&#10;Se encontrar problemas:&#10;1. Documente o problema&#10;2. Verifique console do navegador&#10;3. Teste em outro navegador&#10;4. Ajuste o CSS conforme necessário&#10;&#10;---&#10;&#10;** Bons Testes! O design está pronto para impressionar! **&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/create_db.py" />
              <option name="originalContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import pymysql&#10;&#10;# Configurações do banco MySQL (hardcoded)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 3306&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data', 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao MySQL (sem banco específico)&#10;    conn = pymysql.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, charset='utf8mb4')&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='utf-8') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa&#10;    statements = [s.strip() for s in sql.split(';') if s.strip()]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Banco criado e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/create_db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/create_db.py" />
              <option name="originalContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()&#10;" />
              <option name="updatedContent" value="import os&#10;import psycopg2&#10;&#10;# Configurações do banco PostgreSQL (hardcoded)&#10;DB_USER = 'postgres'&#10;DB_PASS = 'postgres'  # Senha com acento, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = 5432&#10;&#10;# Caminho do arquivo SQL&#10;SQL_FILE = os.path.join(os.path.dirname(__file__), 'data.sql')&#10;&#10;def run_sql():&#10;    # Conecta ao banco 'postgres' para criar o banco 'biblioteca'&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='postgres')&#10;    conn.autocommit = True&#10;    cur = conn.cursor()&#10;&#10;    try:&#10;        cur.execute(&quot;CREATE DATABASE biblioteca;&quot;)&#10;        print(&quot;Banco 'biblioteca' criado.&quot;)&#10;    except psycopg2.errors.DuplicateDatabase:&#10;        print(&quot;Banco 'biblioteca' já existe.&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro ao criar banco: {e}&quot;)&#10;&#10;    cur.close()&#10;    conn.close()&#10;&#10;    # Agora conecta ao banco 'biblioteca' e executa o resto do SQL&#10;    conn = psycopg2.connect(host=DB_HOST, user=DB_USER, password=DB_PASS, port=DB_PORT, database='biblioteca', options=&quot;-c client_encoding=utf8&quot;)&#10;    cur = conn.cursor()&#10;&#10;    with open(SQL_FILE, 'r', encoding='cp1252') as f:&#10;        sql = f.read()&#10;&#10;    # Divide por ; e executa (ignorando CREATE DATABASE)&#10;    statements = [s.strip() for s in sql.split(';') if s.strip() and not s.upper().startswith('CREATE DATABASE')]&#10;    for stmt in statements:&#10;        print(f&quot;Executando: {stmt[:50]}...&quot;)&#10;        cur.execute(stmt)&#10;&#10;    conn.commit()&#10;    cur.close()&#10;    conn.close()&#10;    print(&quot;Tabela criada e dados inseridos automaticamente!&quot;)&#10;&#10;if __name__ == '__main__':&#10;    run_sql()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/db.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/db.py" />
              <option name="originalContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = 'root'&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)&#10;" />
              <option name="updatedContent" value="from sqlalchemy import create_engine, Column, Integer, String, TIMESTAMP, text&#10;from sqlalchemy.orm import declarative_base, sessionmaker&#10;&#10;# Configurações do banco MySQL (hardcoded, similar a properties no Spring Boot)&#10;DB_USER = 'root'&#10;DB_PASS = ''  # Senha vazia, ajuste se necessário&#10;DB_HOST = '127.0.0.1'&#10;DB_PORT = '3306'&#10;DB_NAME = 'biblioteca'&#10;&#10;# URL de conexão MySQL&#10;DATABASE_URL = f&quot;mysql+pymysql://{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}?charset=utf8mb4&quot;&#10;&#10;# Engine e Session&#10;engine = create_engine(DATABASE_URL, echo=False)&#10;SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False)&#10;Base = declarative_base()&#10;&#10;# Modelo da tabela users&#10;class User(Base):&#10;    __tablename__ = 'users'&#10;    id = Column(Integer, primary_key=True)&#10;    username = Column(String(150), unique=True, nullable=False)&#10;    password = Column(String(255), nullable=False)&#10;    created_at = Column(TIMESTAMP, server_default=text('CURRENT_TIMESTAMP'))&#10;&#10;# Função para criar tabelas&#10;def init_db():&#10;    Base.metadata.create_all(bind=engine)&#10;&#10;# Teste de conexão&#10;if __name__ == '__main__':&#10;    try:&#10;        with engine.connect() as conn:&#10;            print(&quot;Conexão com MySQL OK!&quot;)&#10;    except Exception as e:&#10;        print(f&quot;Erro na conexão: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/services/chat_service.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/services/chat_service.py" />
              <option name="originalContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
              <option name="updatedContent" value="import os&#10;import re&#10;import requests&#10;from exceptions.custom_exceptions import (&#10;    BadRequestException,&#10;    UnauthorizedException,&#10;    RateLimitException&#10;)&#10;&#10;&#10;class ChatService:&#10;    GROQ_API_URL = &quot;https://api.groq.com/openai/v1/chat/completions&quot;&#10;&#10;    @staticmethod&#10;    def format_response(raw_text: str) -&gt; str:&#10;        if not raw_text:&#10;            return ''&#10;&#10;        text = re.sub(r'\*\*(.*?)\*\*', r'\1', raw_text)&#10;&#10;        text = re.sub(r'\*(.*?)\*', r'\1', text)&#10;&#10;        text = re.sub(r'`([^`]+)`', r'\1', text)&#10;&#10;        text = re.sub(r'\n{3,}', '\n\n', text)&#10;&#10;        text = text.replace('\n', '&lt;br&gt;')&#10;&#10;        text = text.strip()&#10;&#10;        return text&#10;&#10;    @staticmethod&#10;    def ask(message, api_key=None, model=None, hf_token=None, hf_model=None, **kwargs):&#10;        if not message or not str(message).strip():&#10;            return {&quot;answer&quot;: &quot;Digite uma mensagem para continuar.&quot;}&#10;&#10;        groq_key = api_key or os.environ.get('GROQ_API_KEY')&#10;        if not groq_key:&#10;            raise BadRequestException(&quot;GROQ_API_KEY não configurada&quot;)&#10;&#10;        response = requests.post(&#10;            ChatService.GROQ_API_URL,&#10;            json={&#10;                &quot;model&quot;: model or &quot;llama-3.1-8b-instant&quot;,&#10;                &quot;messages&quot;: [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}],&#10;                &quot;temperature&quot;: 0.7,&#10;                &quot;max_tokens&quot;: 1000&#10;            },&#10;            headers={&quot;Authorization&quot;: f&quot;Bearer {groq_key}&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;},&#10;            timeout=30&#10;        )&#10;&#10;        if response.status_code == 401:&#10;            raise UnauthorizedException(&quot;Groq API key inválida&quot;)&#10;        if response.status_code == 429:&#10;            raise RateLimitException(&quot;Rate limit do Groq atingido&quot;)&#10;        if response.status_code != 200:&#10;            raise Exception(f&quot;Groq error: {response.status_code}&quot;)&#10;&#10;        content = response.json()['choices'][0]['message']['content']&#10;&#10;        formatted_text = ChatService.format_response(content)&#10;&#10;        return {&quot;answer&quot;: formatted_text}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>